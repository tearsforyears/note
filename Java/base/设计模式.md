# 设计模式

---

[TOC]

# 创建模式

---

## **工厂模式factory**

### 静态工厂

产品接口(以打印机为例) 

```java
public interface PrinterInter{
  public void print();
}
```

产品静态工厂

```java
public class PrinterFactory{
  	// 因为提供类的方法是静态的称为静态工厂
    public static PrinterInter createPrinter(Class<? extends PrinterInter> clazz) throws IllegalAccessException, InstantiationException {
      return clazz.newInstance(); // 直接利用反射调用了
  }
}
```

当然我们可以不用反射 被称为简单工厂(略傻)

```java
public class PrinterFactory{
  	// 因为提供类的方法是静态的称为静态工厂
    public static PrinterInter createPrinter(String name){
      if("sony".equals(name)){
        return new SonyPrinter();
      }else if("hp".equals(name)){
        return new HPPrinter();
      }else{
       	return null; 
      }
    }
}
```

main

```java
public static void main(String[] args) {
    PrinterInter priner = PrinterFactory.createPrinter(PrinterImpl.class);
    priner.print();
  	// 根据接口和反射创建对象并且调用方法
}
```

### 实例工厂

工厂的代码变了

```java
public class PrinterFactory{
  	// 因为提供类的方法是普通方法称为实例工厂
    public PrinterInter createPrinter(Class<? extends PrinterInter> clazz) throws IllegalAccessException, InstantiationException {
      return clazz.newInstance(); // 直接利用反射调用了
  }
}
```

### 抽象工厂

这里不多做介绍和抽象类的意义基本一致 为了后面的实例工厂服务 用于建立不同的流水线

### 异同

可以看到静态工厂是不需要我们额外进行类的装配和配置的 如果是想要配置得使用static代码块进行配置 不方便我们修改

而实例工厂可以用构造器对对象进行参数的注入 所以一般使用实例工厂来完成一些需要定制参数的类的创建 而静态工厂是用来创建一些属性值相对固定的类 当然也无绝对得看具体情况而定

## **单例模式singleton**

这是设计模式中最简单的一种模式了 为了就是让该类全局的对象只有一个

### 饿汉模式

思路就是 你全局对象只有一个 定义为常量就行 final static 然后我禁掉你构造函数你就么得创建了

禁用掉构造函数 只要把构造函数的访问符号变成private就可以了

```java
# 饿汉模式
class Singleton {
	private Singleton(){}
	private final static Singleton singleton = new Singleton();
	public static Singleton getInstance(){
		return singleton;
	}
}
```

### 懒汉模式

饿汉模式有一个缺点就是 在加载该类的时候就立刻要申请内存注入到static变量区(方法区)

懒汉模式想法也很简单 需要的时候我在申请内存

```java
// 懒汉模式 - 线程非安全 
class UnsafeLazySingleton{
	private UnsafeLazySingleton(){}
	private static UnsafeLazySingleton lazySingleton;
	public static UnsafeLazySingleton getInstance(){
		if(null == lazySingleton){
			lazySingleton = new UnsafeLazySingleton();
		}
		return lazySingleton;
	}
}
```

至于上面的两个版本都是线程不安全的 我们先获得类中该静态字段的锁然后在创建对象会更安全

当然为了防止内存更新不及时我们还可以加上volatile关键字禁用掉线程局部的共享变量副本

```java
// 懒汉模式 - 线程安全
class SafeLazySingleton{
	private SafeLazySingleton(){}
	private static SafeLazySingleton lazySingleton;
	public static SafeLazySingleton getInstance(){
		synchronized (lazySingleton) {
			if(null == lazySingleton){
				lazySingleton = new SafeLazySingleton();
			}
		}
		return lazySingleton;
	}
}

// 懒汉模式 - 线程安全(优化版)
// 使用synchronized和volatile关键字双向锁定对象
class DoubleLockSafeLazySingleton{
	private DoubleLockSafeLazySingleton(){}
	private volatile static DoubleLockSafeLazySingleton lazySingleton;
	public static DoubleLockSafeLazySingleton getInstance(){
		if(null == lazySingleton){
			synchronized (lazySingleton) {
				if(null == lazySingleton){
					lazySingleton = new DoubleLockSafeLazySingleton();
				}
			}
		}
		return lazySingleton;
	}
}
```

## **原型模式prototype**

我们只用实现其Cloneable接口就可以了

即所说的浅拷贝和深拷贝

```java
// 浅拷贝
class SimpleClone implements Cloneable{
	public Object clone() throws CloneNotSupportedException{
		return super.clone();
	}
}
// 深拷贝
class DeepClone implements Cloneable{
  // 该类中的数据结构成员
	private ArrayList<Integer> arrayList = new ArrayList<>();
	public Object clone() throws CloneNotSupportedException{
		DeepClone obj = (DeepClone)super.clone();
		obj.arrayList = (ArrayList<Integer>)this.arrayList.clone();
		return obj;
	}
}
// 二进制流深拷贝
class ByteDeepClone implements Cloneable{
	public Object deepClone() throws CloneNotSupportedException,IOException, ClassNotFoundException{
			// 写入当前对象的二进制流
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			ObjectOutputStream oos;
			oos = new ObjectOutputStream(bos);
			oos.writeObject(this);
			ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
			ObjectInputStream ois = new ObjectInputStream(bis);
			return ois.readObject();
		
	}
}
```

## **建造者模式builder**

先说builder模式的设计思想 其设计思想和Factory不一样 Factory一出生就是已经注定的类型了(哪怕设计了工厂的初始化参数也是这样) 除非开辟新的工厂否则流水线生产才是工厂模式主要的职责

而建造者模式旨在定制化对象 对于每一个对象的参数最好都是由程序要自己去注入

结合链式编程 设计一个PersonBuilder(ghs?)

有一Person类

```java
class PersonBuilder{
  private Person person = new Person();
  public PersonBuilder setAge(int age){
    person.setAge(age);
    return this;
  }
  public PersonBuilder setName(int name){
    person.setName(name);
    return this;
  }
  public Person build(){
    return person;
  }
}
```

