# Spring需要深入理解的东西

---

-   spring的设计模式

    -   单例模式
    -   工厂模式(实例工厂静态工厂)
    -   代理模式(jdk动态代理)
    -   观察者模式(事件监听)
    -   装饰者模式

-   aop实现底层原理

    -   cglib (继承代理)
    -   jdk动态代理 (公共接口代理)
    -   ASM框架修改字节码
    -   springAOP(运行时增强 基于代理)和AspectJ(编译时增强 基于字节码)的异同

-   ioc创建过程

    整个工厂创建的所有细节

-   不使用事务出现的结果

    -   脏读 select到其他程序update的数据但未commit的数据

        脏读就是读到的数据不对

    -   幻读 select到其他程序insert的数据但未commit的数据

        幻读就是读到原本不存在

    -   不可重复读 两次select到其他程序commit前后的数据

-   事务隔离机制

    下面所谓的commited就是把操作更新到数据库

    read-uncommited 最低的级别 等于不做任何操作

    读写操作都不提交 所以会出现 三种以上结果

    **read-commited(默认操作)** 读操作就要在提交之后进行

    读select之前要其他程序先提交update 以保证提交的是最新的数据 

    其能解决脏读 因为脏读和volatile关键字的原理比较像 其原理应该是把数据拷贝一份到本线程 修改本线程在和主内存同步 read-commit直接禁用了缓存 和jmm中释放锁会把所有线程的东西写回主内存一样

    **其不可解决 幻读问题** 为什么?因为复制过来的副本肯定不包含新插入的行 那么在对应的sql操作的线程中怎么肯能含有相应的数据节点 总不可能把整张表都load进内存

    repeatable_read 其可以解决脏读和不可重复度问题 利用快照实现 就读快照的内容不读原数据库 显而易见只读自己内存副本里面的东西就绝对不会脏读和重复读 但有**幻读**问题

    serializable 把所有操作序列化 所有事物按顺序执行 开销最大

-   事务传播行为

    **所谓的当前有事务指的是另一个事务调用了本事务**
    
    REQUIRED(默认):本事物默认加入其它事务中去执行,如果没有其他事务则重新开启事务
    
    要求一定要有事务来供本方法的代码去执行
    
    SUPPORTS:支持事务顾名思义就是说没有事务其可执行 如果其他方法调用则加入事务
    
    MANDATORY:强制要求事务执行 如果当前有事务加入当前事务 没有就抛异常
    
    ---
    
    NOT_SUPPORTED:不支持事务 当前有事务不加入事务挂起事务 执行完之后执行事务
    
    NEVER: 当前有事务则抛出异常
    
    NESTED:如果有活动事务存在就运行在活动事务中没有就按REQUIRED执行
    
    