# 内存机制

---

Java语言支持动态加载和动态连接。
虚拟机加载类的具体过程

[TOC]

## 类加载总的流程

​	加载->验证->准备->解析->初始化->使用->卸载
​	准备阶段和初始化阶段才可以赋值
​	准备阶段赋默认值,final等

　简单理解 加载-->连接(验证、准备、解析)-->初始化,
	需要注意的是每个阶段之间没有完全清晰的界限,通常是前一个阶段执行到某处就会触发下个阶段的执行。

　2.类加载过程中各步骤的具体任务
	加载阶段：需要完成3个任务。
		1.通过类名获得Class文件(注意：字节码文件的来源可以是任意的)；
		2.将这个字节码文件代表的静态存储结构转换为方法区的运行时数据结构
		3.在Java堆中生成一个代表该类字节码文件的java.lang.Class文件的对象，该对象作为程序访问方法区数据的入口。

　　验证：验证是连接的第一步，主要的目的是确保字节码文件中的信息符合虚拟机的要求，
	并且不会对虚拟机造成伤害。不同的虚拟机对字节码
	文件的验证可能会不同，主要分为4部分的验证：

　　文件格式验证：
	检验字节码文件的格式规范，并且验证是否能被当前版本的虚拟机处理。只有完成这部分验证，字节码文件才能进入方法区，
	后面3个部分的验证是基于方法区的验证。

　　元数据验证：对字节码的描述信息进行语义分析，确保描述信息符合Java语言规范。

　　字节码验证：是整个验证过程中最复杂的部分，主要是对数据流和控制流的验证，确保类的方法在运行的时候不会对虚拟机造成危害。
　　符号引用验证：这个阶段发生在虚拟机将符合引用转换为直接引用的过程中，这部分发生解析阶段。这个阶段的目的就是确保解析阶段
	可以被正常的执行。

　　准备：目的是对所有的类变量--静态成员变量进行默认初始化。
	但final关键字可以让这个初始化的值发生改变。

　　解析：将虚拟机常量池中的符号引用转换为直接引用的过程。分为4类，类或接口的解析；字段的解析；类方法的解析、接口方法的解析

　　初始化：执行字节码文件定义的初始化。

## 初始化阶段
1.执行类的构造器(classinit)就是把所有static和赋值语句执行<clint>
2.执行对象初始化方法(init)//先执行自身变量在执行方法初始化<init>

初始化小型规律:
先执行父类在执行子类(c++中说法是先初始化基类在初始化派生类)
先初始化成员变量在初始化方法

classinit方法收集所有赋值动作和静态语句块

```java
public class Test
{
    static
    {
        i=0;//合法可以赋值
        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）
    	//不合法不可访问之后的变量
    }
    static int i=1;//定义位置
}
```

static语句块和赋值语句会进行合并,进行classinit
父类会先于子类执行classinit
如果没有赋值或者静态语句快则不会执行classinit方法
虚拟机保证classinit方法加锁

虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1.遇到new,getstatic,putstatic,invokestatic这失调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：

使用new关键字实例化对象的时候

//注意 new ClassName[10];利用数组定义不会进行初始化。
->读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，
以及调用一个类的静态方法的时候。

注意只有直接定义字段/方法的这个类会被初始化,其子类调用是不会触发初始化的。

2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。//反射调用的时候需要进行初始化

3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
	//类加载
4.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5.当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。


类与类加载器
　　类加载器：其实就是一段代码用来实现类的加载，但是需要注意的是使用不同的类加载器加载，在堆中生成的Class对象是不相等的。
　　类加载器的分类：启动类加载器(属于JVM的一部分)、扩展类加载器、应用程序类加载器，
	以及自定义的类加载器。通常应用程序的加载都是由这3种
　　加载器配合一起完成类的加载。
　　类加载器的双亲委派模型：
	如果一个类加载器收到了类加载的亲求，先传给其上级的类加载器，看是否被加载过，每一级类加载器都是这样操作
　　上级类记载器没加载过，自己又不想加载的时候，下级类加载器才开始工作。注意：各级类加载器类之间的关系是组合关系，不是继承。

GC:
	主动调用 System.gc();
	垃圾回收机制回收没有被引用变量引用的对象。
	当Java对象被创建出来后，垃圾回收机制会实时监控每一个对象的运行状态，如：对象申请，引用，被引用，赋值等。当垃圾回收机制监控到某个对象不再被引用变量引用时，垃圾回收机制就会回收它所占用的空间。 
　　所以！在我们不再需要使用一个对象时，要记得取消对该对象的所有引用，
	这样，垃圾回收机制才能自动回收它，否则就会造成内存泄漏。
	复制实际算法:
		新生代:大规模清理对象
		copying算法:堆内存分割成两个空间 递归访问可达对象复制到其中一半
		//遍历空间成本小，复制成本大
		老年代:对象存活率高，没有额外空间
		Mark-Sweep:递归遍历标记可达对象，然后全部遍历回收没标记的对象
		//碎片多，遍历两次，内存利用率高
		Mark-Compact:标记整理 标记可达对象，搬到同一区域，回收不可达对象
	GC内存管理技巧
	1.尽量使用直接量
	2.使用StringBuilder和StringBuffer
	3.无用对象设置为null
	4.少使用静态对象
	5.尽量避免在常用方法循环中创建对象
	6.缓存经常使用的对象
		1.文件
		2.内存缓存(用一个map结构实现)
	7.考虑使用SoftReference
	8.使用int类型等少使用包装类
	9.减少同一时间大量创建对象(减少gc使用频率)
	10.不要显式调用System.gc()、finalize方法




	总结:
	gc回收没有引用的对象，只在线程空闲时候进行回收，或者在堆内存不够的时候进行回收
JAVA 内存分配:
	一、 基本概念

	每运行一个java程序会产生一个java进程，每个java进程可能包含一个或者多个线程，每一个Java进程对应唯一一个JVM实例，每一个JVM实例唯一对应一个堆，每一个线程有一个自己私有的栈。进程所创建的所有类的实例（也就是对象）或数组（指的是数组的本身，不是引用）都放在堆中,并由该进程所有的线程共享。Java中分配堆内存是自动初始化的，即为一个对象分配内存的时候，会初始化这个对象中变量。虽然Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在栈中分配,也就是说在建立一个对象时在堆和栈中都分配内存，在堆中分配的内存实际存放这个被创建的对象的本身，而在栈中分配的内存只是存放指向这个堆对象的引用而已。局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。
	
	具体的概念：JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method，也叫静态区)：
	
	堆区: 
	
	1.存储的全部是对象，每个对象都包含一个与之对应的class的信息(class的目的是得到操作指令) ；
	2.jvm只有一个堆区(heap)，且被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身和数组本身；
	
	栈区: 
	1.每个线程包含一个栈区，栈中只保存基础数据类型本身和自定义对象的引用；
	2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问；
	3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)；
	
	方法区（静态区）: 
	1.被所有的线程共享，方法区包含所有的class（class是指类的原始代码，要创建一个类的对象，首先要把该类的代码加载到方法区中，并且初始化）和static变量。 
	2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 
双亲委派模型:
	双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。


```

```