# jvm

---

[TOC]

Java virtual machine

之前已经写过类似的文档 但总结起来就是每次都有新的认识

写于2020年

### index

-   内存结构 
-   类加载过程
    -   ***类的初始化***
-   Javaapi/shell 
-   GC

### 简单内存结构

​	heap 用于存放process级别数据 class内的变量等 new 出来的变量等 数组等

​	stack 存放thread/function级别数据 局部变量操作数栈动态链接方法出口

​	方法区 process级数据 常量池 static变量区 类接口等加载去

​	navtive 方法区 global级别数据 被jvm环境使用 存放c++实现的方法 主要针对字节码操作

​	在多线程中还会进一步深化此知识 不过对于内存结构而言 相对简单如上的模型是

### 类加载过程

-   加载前

    Complier完成对.java文件的编译变成.class文件

    这个编译过程会对一些运算进行替换比如1==1替换成true

    这一阶段就会加入常量池

    其实没仔细说明 这一阶段所有final变量也会加入常量池留下引用

    常量池有字面量 符号引用和 运行时常量池

    通过javah命令编译之后，用javap -v 命令查看编译后的文件

-   加载

    从class中加载字节流 在方法区生成入口type=Class的对象

-   连接

    验证 准备 解析

    这个过程主要加载类的static变量完成默认值注入(只针对变量) 生成引用 

    ***对final static变量直接注入值***

-   ClassLoader

    ClassLoader只负责前面三部分 

    除了隐式或者显示的new以外 形如Class.forName

    和ClassInstace.staticMethod都不进行初始化只加载到jvm

    机制主要是三种

    -   全盘负责 该类依赖的所有类都由该类的classloader加载

    -   缓存机制 先去缓存区域找 找不到了在去.class文件中加载

    -   双亲委派模型(主要) 

        用户加载器->应用加载器/系统加载器/上下文加载器->扩展加载器->根加载器

        按照此方式往上加载类
        
        好处是父类加载了就没必要自己加载一次
        
        平时默认是使用系统加载器的 也可以自己制自己的加载器
        
        ```java
        Class.forName(); 
        // 用当前类加载器
        Classloader.getSystemClassLoader().loadClass();
        // 用系统加载器
        Thread.currentThread().getContextClassLoader().loadClass();
        // 用上下文加载器
        ```
        
        

    ClassLoader的代码结构

    -   **defineClass** 

        byte流解析成jvm能够识别的对象

    -    **findClass** 

        通过类名去加载对象,通常我们定义自己的类加载器用该方法实现

    -    **loadClass** 

        加载类到JVM

    -    **resolveClass**

        动调用这个使得被加到JVM的类被链接

    双亲委派模型

    ​	![图片](https://upload-images.jianshu.io/upload_images/1833901-97c7f6c8d8e0965f.png)

-   ***初始化***

    clinit方法和init方法 是指类的初始化和对象的初始化

    而注意一点 无clinit在执行的时候会阻塞所有static变量和代码块

    在编译.class文件的时候注入到字节码里面

    -   clinit是类的初始化

        Static变量的赋值初始化 执行static代码块

        该方法只执行一次 若类中无static代码块 和 static变量 则没有该方法

    -   init是实例的初始化

        实例初始化 类的构造方法和普通代码块的执行
        
    -   初始化顺序和方法执行特点

        ***1.类的初始化*** clinit方法的特性

        ​	先执行父类在执行子类,

        ​	先执行staic方法在执行普通方法,

        ​	先初始化成员变量在初始化方法

        ​	多个线程执行的时候blocked 只有唯一clinit方法在执行

        ​	***而静态代码块和静态成员变量按顺序从类的上往下依次执行***

        ​	***数组定义不会触发初始化！！ 本质上是加载数组类***

        ​	类的初始化条件 本质上是new,getstatic,putstatic,invokestatic指令执行的时候
        
        	1. new 不包括 new ClassName[10]
         	2. 反射调用的时候
         	3. 父类初始化
 	4. 虚拟机加载的时候
         	5. 方法invoke 内部有隐式的new

        ***2.对象的初始化*** init方法特性
        
        ​	执行变量初始化 方法指针生成等 和clinit类似
        
        ***3.初始化顺序***
        
        ```note
        1.初始化父类代码块 初始化父类final static 初始化父类static 
        //同一时间按序执行
        2.初始化子类代码块 初始化子类final static 初始化子类static
        3.初始化父类普通成员变量 初始化父类final 初始化父类普通代码块
        4.初始化子类普通成员变量 初始化子类final 初始化父类普通代码块
        ```

**学会了?来试试下面习题吧**

```java
public class StaticTest{
    public static void main(String[] args){
        staticFunction();
    }

    static StaticTest st = new StaticTest();

    static{
        System.out.println("1");
    }

    {
        System.out.println("2");
    }

    StaticTest(){
        System.out.println("3");
        System.out.println("a="+a+",b="+b);
    }

    public static void staticFunction(){
        System.out.println("4");
    }

    int a=110;
    static int b =112;
}
```

-   使用
-   卸载

### javaapi/shell获取jvm相关信息

```shell
java -verbose:class 即可查看加载了哪些类
java -verbose:gc 可查看gc清理
```

java 主要通过java.lang.management相关的类实现功能

```java
import java.lang.management.ClassLoadingMXBean;
import java.lang.management.CompilationMXBean;
import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryManagerMXBean;
import java.lang.management.MemoryPoolMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.OperatingSystemMXBean;
import java.lang.management.RuntimeMXBean;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
 
public class JvmInfo {
 
	static final long MB = 1024 * 1024;
	
	public static void main(String[] args) {
		
				
		//打印系统信息
		System.out.println("===========打印系统信息==========");
		printOperatingSystemInfo();
		//打印编译信息
		System.out.println("===========打印编译信息==========");
		printCompilationInfo();
		//打印类加载信息
		System.out.println("===========打印类加载信息==========");
		printClassLoadingInfo();
		//打印运行时信息
		System.out.println("===========打印运行时信息==========");
		printRuntimeInfo();
		//打印内存管理器信息
		System.out.println("===========打印内存管理器信息==========");
		printMemoryManagerInfo();
		//打印垃圾回收信息
		System.out.println("===========打印垃圾回收信息==========");
		printGarbageCollectorInfo();
		//打印vm内存
		System.out.println("===========打印vm内存信息==========");
		printMemoryInfo();
		//打印vm各内存区信息
		System.out.println("===========打印vm各内存区信息==========");
		printMemoryPoolInfo();
		//打印线程信息
		System.out.println("===========打印线程==========");
		printThreadInfo();
		
	}
	
	
	private static void printOperatingSystemInfo(){
		OperatingSystemMXBean system = ManagementFactory.getOperatingSystemMXBean();
		//相当于System.getProperty("os.name").
		System.out.println("系统名称:"+system.getName());
		//相当于System.getProperty("os.version").
		System.out.println("系统版本:"+system.getVersion());
		//相当于System.getProperty("os.arch").
		System.out.println("操作系统的架构:"+system.getArch());
		//相当于 Runtime.availableProcessors()
		System.out.println("可用的内核数:"+system.getAvailableProcessors());
		
		if(isSunOsMBean(system)){
			long totalPhysicalMemory = getLongFromOperatingSystem(system,"getTotalPhysicalMemorySize");
			long freePhysicalMemory = getLongFromOperatingSystem(system, "getFreePhysicalMemorySize");
			long usedPhysicalMemorySize =totalPhysicalMemory - freePhysicalMemory;
			
			System.out.println("总物理内存(M):"+totalPhysicalMemory/MB);
			System.out.println("已用物理内存(M):"+usedPhysicalMemorySize/MB);
			System.out.println("剩余物理内存(M):"+freePhysicalMemory/MB);
			
			long  totalSwapSpaceSize = getLongFromOperatingSystem(system, "getTotalSwapSpaceSize");
			long freeSwapSpaceSize = getLongFromOperatingSystem(system, "getFreeSwapSpaceSize");
			long usedSwapSpaceSize = totalSwapSpaceSize - freeSwapSpaceSize;
			
			System.out.println("总交换空间(M):"+totalSwapSpaceSize/MB);
			System.out.println("已用交换空间(M):"+usedSwapSpaceSize/MB);
			System.out.println("剩余交换空间(M):"+freeSwapSpaceSize/MB);
		}
	}
	
	private static long getLongFromOperatingSystem(OperatingSystemMXBean operatingSystem, String methodName) {
		try {
			final Method method = operatingSystem.getClass().getMethod(methodName,
					(Class<?>[]) null);
			method.setAccessible(true);
			return (Long) method.invoke(operatingSystem, (Object[]) null);
		} catch (final InvocationTargetException e) {
			if (e.getCause() instanceof Error) {
				throw (Error) e.getCause();
			} else if (e.getCause() instanceof RuntimeException) {
				throw (RuntimeException) e.getCause();
			}
			throw new IllegalStateException(e.getCause());
		} catch (final NoSuchMethodException e) {
			throw new IllegalArgumentException(e);
		} catch (final IllegalAccessException e) {
			throw new IllegalStateException(e);
		}
	}
 
	private static void printCompilationInfo(){
		CompilationMXBean compilation = ManagementFactory.getCompilationMXBean();
		System.out.println("JIT编译器名称："+compilation.getName());
		//判断jvm是否支持编译时间的监控
		if(compilation.isCompilationTimeMonitoringSupported()){
			System.out.println("总编译时间："+compilation.getTotalCompilationTime()+"秒");
		}
	}
	
	private static void printClassLoadingInfo(){
		ClassLoadingMXBean classLoad= ManagementFactory.getClassLoadingMXBean();
		System.out.println("已加载类总数："+classLoad.getTotalLoadedClassCount());
		System.out.println("已加载当前类："+classLoad.getLoadedClassCount());
		System.out.println("已卸载类总数："+classLoad.getUnloadedClassCount());
		
	}
	
	private static void printRuntimeInfo(){
		RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
		System.out.println("进程PID="+runtime.getName().split("@")[0]);
		System.out.println("jvm规范名称:"+runtime.getSpecName());
		System.out.println("jvm规范运营商:"+runtime.getSpecVendor());
		System.out.println("jvm规范版本:"+runtime.getSpecVersion());
		//返回虚拟机在毫秒内的开始时间。该方法返回了虚拟机启动时的近似时间
		System.out.println("jvm启动时间（毫秒）:"+runtime.getStartTime());
		//相当于System.getProperties
		System.out.println("获取System.properties:"+runtime.getSystemProperties());
		System.out.println("jvm正常运行时间（毫秒）:"+runtime.getUptime());
		//相当于System.getProperty("java.vm.name").
		System.out.println("jvm名称:"+runtime.getVmName());
		//相当于System.getProperty("java.vm.vendor").
		System.out.println("jvm运营商:"+runtime.getVmVendor());
		//相当于System.getProperty("java.vm.version").
		System.out.println("jvm实现版本:"+runtime.getVmVersion());
		List<String> args = runtime.getInputArguments();
		if(args != null && !args.isEmpty()){
			System.out.println("vm参数:");
			for(String arg : args){
				System.out.println(arg);
			}
		}
		System.out.println("类路径:"+runtime.getClassPath());
		System.out.println("引导类路径:"+runtime.getBootClassPath());
		System.out.println("库路径:"+runtime.getLibraryPath());
	}
	
	private static void printMemoryManagerInfo(){
		List<MemoryManagerMXBean> managers = ManagementFactory.getMemoryManagerMXBeans();
		if(managers != null && !managers.isEmpty()){
			for(MemoryManagerMXBean manager : managers){
				System.out.println("vm内存管理器：名称="+manager.getName()+",管理的内存区="
			+Arrays.deepToString(manager.getMemoryPoolNames())+",ObjectName="+manager.getObjectName());
			}
		}
	}
	
	private static void printGarbageCollectorInfo(){
		List<GarbageCollectorMXBean> garbages = ManagementFactory.getGarbageCollectorMXBeans();
		for(GarbageCollectorMXBean garbage : garbages){
			System.out.println("垃圾收集器：名称="+garbage.getName()+",收集="+garbage.getCollectionCount()+",总花费时间="
		+garbage.getCollectionTime()+",内存区名称="+Arrays.deepToString(garbage.getMemoryPoolNames()));
		}
	}
	
	private static void printMemoryInfo(){
		MemoryMXBean memory = ManagementFactory.getMemoryMXBean();
		MemoryUsage headMemory = memory.getHeapMemoryUsage();
		System.out.println("head堆:");
		System.out.println("\t初始(M):"+headMemory.getInit()/MB);
		System.out.println("\t最大(上限)(M):"+headMemory.getMax()/MB);
		System.out.println("\t当前(已使用)(M):"+headMemory.getUsed()/MB);
		System.out.println("\t提交的内存(已申请)(M):"+headMemory.getCommitted()/MB);
		System.out.println("\t使用率:"+headMemory.getUsed()*100/headMemory.getCommitted()+"%");
		
		System.out.println("non-head非堆:");
		MemoryUsage nonheadMemory = memory.getNonHeapMemoryUsage();
		System.out.println("\t初始(M):"+nonheadMemory.getInit()/MB);
		System.out.println("\t最大(上限)(M):"+nonheadMemory.getMax()/MB);
		System.out.println("\t当前(已使用)(M):"+nonheadMemory.getUsed()/MB);
		System.out.println("\t提交的内存(已申请)(M):"+nonheadMemory.getCommitted()/MB);
		System.out.println("\t使用率:"+nonheadMemory.getUsed()*100/nonheadMemory.getCommitted()+"%");
	}
	
	private static void printMemoryPoolInfo(){
		List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
		if(pools != null && !pools.isEmpty()){
			for(MemoryPoolMXBean pool : pools){
				//只打印一些各个内存区都有的属性，一些区的特殊属性，可看文档或百度
				//最大值，初始值，如果没有定义的话，返回-1，所以真正使用时，要注意
				System.out.println("vm内存区:\n\t名称="+pool.getName()+"\n\t所属内存管理者="+Arrays.deepToString(pool.getMemoryManagerNames())
						+"\n\t ObjectName="+pool.getObjectName()+"\n\t初始大小(M)="+pool.getUsage().getInit()/MB
						+"\n\t最大(上限)(M)="+pool.getUsage().getMax()/MB
						+"\n\t已用大小(M)="+pool.getUsage().getUsed()/MB
						+"\n\t已提交(已申请)(M)="+pool.getUsage().getCommitted()/MB
						+"\n\t使用率="+(pool.getUsage().getUsed()*100/pool.getUsage().getCommitted())+"%");
			
			}
		}
	}
	
	private static void printThreadInfo(){
		ThreadMXBean thread = ManagementFactory.getThreadMXBean();
		System.out.println("ObjectName="+thread.getObjectName());
		System.out.println("仍活动的线程总数="+thread.getThreadCount());
		System.out.println("峰值="+thread.getPeakThreadCount());
		System.out.println("线程总数（被创建并执行过的线程总数）="+thread.getTotalStartedThreadCount());
		System.out.println("当初仍活动的守护线程（daemonThread）总数="+thread.getDaemonThreadCount());
		
		//检查是否有死锁的线程存在
		long[] deadlockedIds =  thread.findDeadlockedThreads();
		if(deadlockedIds != null && deadlockedIds.length > 0){
			ThreadInfo[] deadlockInfos = thread.getThreadInfo(deadlockedIds);
			System.out.println("死锁线程信息:");
			System.out.println("\t\t线程名称\t\t状态\t\t");
			for(ThreadInfo deadlockInfo : deadlockInfos){
				System.out.println("\t\t"+deadlockInfo.getThreadName()+"\t\t"+deadlockInfo.getThreadState()
						+"\t\t"+deadlockInfo.getBlockedTime()+"\t\t"+deadlockInfo.getWaitedTime()
						+"\t\t"+deadlockInfo.getStackTrace().toString());
			}
		}
		long[] threadIds = thread.getAllThreadIds();
		if(threadIds != null && threadIds.length > 0){
			ThreadInfo[] threadInfos = thread.getThreadInfo(threadIds);
			System.out.println("所有线程信息:");
			System.out.println("\t\t线程名称\t\t\t\t\t状态\t\t\t\t\t线程id");
			for(ThreadInfo threadInfo : threadInfos){
				System.out.println("\t\t"+threadInfo.getThreadName()+"\t\t\t\t\t"+threadInfo.getThreadState()
						+"\t\t\t\t\t"+threadInfo.getThreadId());
			}
		}
		
	}
	
	private static boolean isSunOsMBean(OperatingSystemMXBean operatingSystem) {
		final String className = operatingSystem.getClass().getName();
		return "com.sun.management.OperatingSystem".equals(className)
				|| "com.sun.management.UnixOperatingSystem".equals(className);
	}
}
```

### GC

gc主要三种算法

Mark-compact算法 存活对象向一个方向移动

Mark-sweep算法 直接回收产生内碎片

Copying算法 回收之后复制整齐 性能开销太大

GC:
	主动调用 System.gc();
	垃圾回收机制回收没有被引用变量引用的对象。
	当Java对象被创建出来后，垃圾回收机制会实时监控每一个对象的运行状态，如：对象申请，引用，被引用，赋值等。当垃圾回收机制监控到某个对象不再被引用变量引用时，垃圾回收机制就会回收它所占用的空间。 
　　所以！在我们不再需要使用一个对象时，要记得取消对该对象的所有引用，
	这样，垃圾回收机制才能自动回收它，否则就会造成内存泄漏。
	复制实际算法:
		新生代:大规模清理对象
		copying算法:堆内存分割成两个空间 递归访问可达对象复制到其中一半
		//遍历空间成本小，复制成本大
		老年代:对象存活率高，没有额外空间
		Mark-Sweep:递归遍历标记可达对象，然后全部遍历回收没标记的对象
		//碎片多，遍历两次，内存利用率高
		Mark-Compact:标记整理 标记可达对象，搬到同一区域，回收不可达对象
	GC内存管理技巧
	1.尽量使用直接量
	2.使用StringBuilder和StringBuffer
	3.无用对象设置为null
	4.少使用静态对象
	5.尽量避免在常用方法循环中创建对象
	6.缓存经常使用的对象
		1.文件
		2.内存缓存(用一个map结构实现)
	7.考虑使用SoftReference
	8.使用int类型等少使用包装类
	9.减少同一时间大量创建对象(减少gc使用频率)
	10.不要显式调用System.gc()、finalize方法

#### 引用类型

强引用,弱引用,软引用,虚引用

强引用:Object obj=new Object(); // 我们平时自己new出来的有带变量接受称强引用

如果这些对象是OutOfMemoryError 也就是说jvm不可能回收这类对象

弱引用:new Object(); // 没有明确变量引用时jvm会考虑回收

软引用:obj=null; //只有在内存不足的时候JVM才会回收该对象一般我们会配合ReferenceQueue去使用

```java
import java.lang.ref.SoftReference; 
public class SoftRef {  
    public static void main(String[] args){  
        System.out.println("start");            
        Obj obj = new Obj();            
        SoftReference<Obj> sr = new SoftReference<Obj>(obj);  
        obj = null;  
        System.out.println(sr.get());  
        System.out.println("end");     
    }       
}
class Obj{  
    int[] obj ;  
    public Obj(){  
        obj = new int[1000];  
    }  
}
```

虚引用:在任何时候都可能被垃圾回收器回收

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
public class PhantomRef {
    public static void main(String[] args) {
        ReferenceQueue<String> queue = new ReferenceQueue<String>();
        PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
        System.out.println(pr.get());
    }
}
```

| 引用类型 | 被回收时间    | 用途           | 生存时间      |
| -------- | ------------- | -------------- | ------------- |
| 强引用   | 从来不会      | 对象的一般状态 | JVM停止运行时 |
| 软引用   | 内存不足时    | 对象缓存       | 内存不足时    |
| 弱引用   | jvm垃圾回收时 | 对象缓存       | gc运行后      |
| 虚引用   | 未知          | 未知           | 未知          |

在实际使用的过程中弱引用与虚引用几乎没用到

所以我们使用完对象一般把变量置为null