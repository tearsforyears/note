# 多线程

---

[TOC]

## 文档使用说明

---

写于2020 java的多线程机制相对复杂 前提是了解JVM的加载过程 理解此中机制实现会比较好一点 其认知的机制请按照以下顺序来会比较好 该文档写的相对不那么离散 但因为曾经有过多线程的编程经验而非纯粹的开始 更像review而不像guide 请按顺序阅读 需要面向对象的基础 jvm的基础可以直接开始阅读本文档

本文档从内存说起 多线程涉及线程安全问题 内存屏障等机制的存在也是为了解决多线程问题

---

## JVM内存模型

---

稍微一提jvm的内存结构

**heap 用于存放process级别数据** class内的变量等 new 出来的变量等 数组等

**stack 存放thread/function级别数据** 局部变量操作数栈动态链接方法出口

**方法区 process级数据** 常量池 static变量区 类接口等加载去

**navtive 方法区 global级别数据** 被jvm环境使用 存放c++实现的方法 主要针对字节码操作

## JMM内存模型

---

即多线程下内存模型 java memory model 我们要研究的主体为线程堆栈(thread stack)

### 线程栈Thread Stack

线程栈对于其他线程是不可见的,包含了线程的局部变量等

进程的栈和线程的栈也是不互通的 只有堆中的局部变量能够进行互相访问

而且堆中的内存都是拷贝的线程的栈中才能进行使用的

### javajava多线程的特性

1.  具有不同的阻塞(Block)类型 等待阻塞 锁定阻塞 IO阻塞
2.  多种多样的锁机制

## 线程安全问题

要保证线程安全就要考虑以下3个特性

1.  原子性 在java中主要是锁机制 可以用原语或其他机制实现
2.  可见性 volatile **脏读问题**
3.  有序性 happen-before原子

## 如何创建线程

```java
// 创建线程的方法
// 0.继承Thread类
// 1.实现Runnable接口 简单实现run方法 
Thread(()->{System.out.print(Thread.currentThread().getName())}).start()
// 2.实现Callable接口 这个和后面线程池相关简单讲下
// Callable优势在于执行之后可以返回值 Runable不行 call()可以抛出异常run()不行
// Callable对象拿到一个Future对象获得线程执行结果
```

## java线程的状态以及其他方法

---

![线程状态](https://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg)

一共有五中状态 可执行(Runnable) 正在执行(Running) 

***Block(普通阻塞) 等待Block(wait) 锁定Blocked(synchronized)***

```java
Thread.start() // 加入就绪队列
Thread.yield() // 让步 放入就绪队列队尾 要慎重使用 因为有准备时间 所以实际是running一会在回到就绪队列的慎用
Thread.sleep() // 计时阻塞
Thread.join()	// 阻塞 如果刚创建就执行阻塞则会中断主线程的执行
// 以上阻塞不涉及java中的锁机制

synchronized(this){ // 得和在同步代码块中使用 获得类的对象或者实例的对象
Thread.wait() 
// 进入和该对象有关的等待区域 释放锁对象 可传入参数 在参数的时间结束后开始等待
// 相比于sleep 不需要进行异常捕获
Thread.notify() Thread.notifyAll() // 唤醒同步
}
```

```java
// wait notify 实现先后执行 在同一个类内
int i = 0; // 共享数据 mutex
public void fun1(){
  synchronized(this){
    if(i==0){
      // 操作1
    }
    i = 1;
    Thread.notifyAll();
  }
}
public void fun2(){
  synchronized(this){
    if(i!=0){
    	wait(); 
    }
  }
}
```



## ***synchronized关键字***

---

synchronized 关键字时java中比较重要的东西 其可以实现原子性和可见性 可用于代替下面的volatile关键字

synchronized 保证代码块或者方法在运行时 同一时刻只有一个对象可以进入到临界区，同时它还可以保证共享变量的内存可见性

1.  ### 普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁

2.  ### 静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁

3.  ### 同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

简单点来讲就是 我们想阻断i++交替访问 直接在方法上加锁就可以了

### 普通方法加synchronized关键字

```java
public class synctest extends Thread{
    static int im = 0;

    @Override
    public synchronized void run() {
        for (int i = 0; i < 10000; ++i) {
            im++;
        }
      	System.out.println(im); 
      // 最后输出结果不是20000 但加上sync关键字后就变成了20000
      // 其原因就在于对对象加了锁 意味着只有一个对象能调用此函数
      // 我们也可以对static加锁 那就是对Class的对象加锁 一个
    }

    public static void main(String[] args) throws InterruptedException {
        synctest s1=new synctest();
        Thread t1 = new Thread(s1);
      	Thread t2 = new Thread(s1); // 因为是普通方法所以引用得一样
        s1.start();
        s2.start();
    }
}
```

如果一个类中有两个不同的同步方法 必须等待其中一个执行完之后才能执行第二个

因为虽然说都是同一个类的不同方法但都获取了对象的锁 所以没办法实现 并发

这个就体现出该关键字设计的臃肿了 当然 也只有同步方法会要求锁 普通方法还是随意使用

**所以普通方法的关键点就是获取实例对象的锁 相同实例对象持有相同的锁 不同实例对象持有不同的锁**

### 静态方法加synchronized关键字

```java
public static void main(String[] args) throws InterruptedException {        
  Thread t2 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  Thread t1 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  t1.start();
  t2.start();
  t1.join();
  t2.join();
  System.out.println(stMethodTest.i); 
  // 不会是20000 而加上sync关键字之后 只要是调用该(同一)类的方法(不是对象)就
  // 就会被阻塞 直到前一个类退出临界区为止
}
class stMethodTest{
    static int i=0;
    static void ins(){
        i++;
    }
}
```

可以看见 其因为持有类对象的锁所以并发性进一步减小 显得臃肿

### 同步代码块

如果在一个大方法内执行全部同步代码显得操作及其耗时耗力 所以只用一小部分代码完成同步就可以实现并发了 基于这个思想 java有了同步代码快的机制 其可以写在方法里

```java
public void run(){
  synchronized(this){ // 作用域该对象 可以视为对普通方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
public void run(){
  synchronized(this.getClass()){ // 作用域该类 可以视为对静态方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
```

## volatile关键字(脏读)

其本质的实现保证的线程安全 主要实现的原理是 主内存(进程堆中的值立刻更新) 而不是更新堆栈的值 其保证了一个变量的可见性(能够立即读取更新值)

可以用于解决脏读问题 但不可解决原子性问题所以依然可能会发生线程安全问题

```java
public class threadstest3 extends Thread{
    /**
     * 测试volatile关键字可读性
     * */
    boolean flag = false; 
  	// 不加关键字时 死循环依然在执行
 		// 加了关键字之后
    int i = 0;
    @Override
    public void run() {
        while (!flag) {
            i++;
        }
    }

    public static void main(String[] args) throws Exception {
        threadstest3 vt = new threadstest3();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println("stop at " + vt.i);
    }
}
```

而保证了可见性并不代表是线程安全的 如下就是一个例子 如果操作不是原子性线程依然不安全

```java
package com.test.sync;

public class threadstest2 {
    /**
     * 证明了volatile破除了关键字 不一定能保证线程安全
     */

    public static void main(String[] args)throws Exception{
        TestClass tc = new TestClass();
        for (int i = 0; i < 1000; i++) {
            tc.startThread();
        }
    }
}

class TestClass {
    volatile Integer count = 0;
    // 不加关键字的时候 最后输出的结构随机
    // 加了关键字之后 依然没有能够完全按照我们的逻辑去执行
    // 其原因就是volatile只是线程间可见 但如果操作不是原子性的话依然有可能出错

    public void startThread() throws Exception{
        new Thread(() -> {
            count++;
            System.out.println(count);
        }).start();
    }
}
```

## 实现基本的同步问题

### 生产者消费者

### 读者写者

## 线程池的使用

## happen-before原则

## 原子性相关

除了上述用synchronized 关键字和锁机制实现原子性之外 还可以通过CAS机制 信号量机制等

赋值操作并不一定是原子操作 如果32位机子用64位变量cpu还要两次才能完成赋值操作

大多数情况下 赋值操作是原子性操作

java中有一些类是可原子性操作的AtomicInteger,AtomicLong,AtomicBoolean

他们都是通过CAS完成原子性的

### CAS

Compare and Swap 三个参数内存值V 旧的期望值A 新的期望值B

当A=V时 把V修改为B 否则什么也不做 如下伪代码

是一种无锁算法

伪代码如下

```note
do{
	备份旧数据;
	基于旧数据构造新数据; // 计算
}while(!CAS( 内存地址，备份的旧数据，新数据 ))
这个循环的运行结果只有一种情况 
其思想相当简单 如果旧数据被改那么我重新再执行一遍计算
如果没被改 我就能把计算的值放到里面去 
由于CAS 只用执行一条CPU指令所以其为原子性操作(当然也有很特殊的情况默认为是原子性)
```

## synchronized关键字的实现原理

jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

jvm首先看方法表中有没有同步方法 如果有 那么则令线程现持有monitor(管程) 在方法执行完后的时候释放monitor 这是隐式的实现 不利用到字节码

代码块的同步是利用monitorenter和monitorexit这两个字节码指令 其实所谓的锁就是一个程序计数器 有多少程序进入其中就加1或者减1

而monitor的本质是基于mutex 实现的互斥  // 大写的卧槽 

称此种依赖mutex实现的锁为重量锁

java1.6引入了偏向锁的机制一共有4种状态,级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态 锁可以升级但不能降级

偏向锁的获取：

判断是否为可偏向状态
如果为可偏向状态，则判断线程ID是否是当前线程，如果是进入同步块；
如果线程ID并未指向当前线程，利用CAS操作竞争锁，如果竞争成功，将Mark Word中线程ID更新为当前线程ID，进入同步块
如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活动状态，决定是转换为无锁状态还是升级为轻量级锁。

