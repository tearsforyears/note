# 多线程

---

[TOC]

## 文档使用说明

---

写于2020 java的多线程机制相对复杂 前提是了解JVM的加载过程 理解此中机制实现会比较好一点 其认知的机制请按照以下顺序来会比较好 该文档写的相对不那么离散 但因为曾经有过多线程的编程经验而非纯粹的开始 更像review而不像guide 请按顺序阅读 需要面向对象的基础 jvm的基础可以直接开始阅读本文档

本文档从内存说起 多线程涉及线程安全问题 内存屏障等机制的存在也是为了解决多线程问题

---

## JVM内存模型

---

稍微一提jvm的内存结构

**heap 用于存放process级别数据** class内的变量等 new 出来的变量等 数组等

**stack 存放thread/function级别数据** 局部变量操作数栈动态链接方法出口

**方法区 process级数据** 常量池 static变量区 类接口等加载去

**navtive 方法区 global级别数据** 被jvm环境使用 存放c++实现的方法 主要针对字节码操作

## JMM内存模型

---

即多线程下内存模型 java memory model 我们要研究的主体为线程堆栈(thread stack)

### 线程栈Thread Stack

线程栈对于其他线程是不可见的,包含了线程的局部变量等

进程的栈和线程的栈也是不互通的 只有堆中的局部变量能够进行互相访问

而且堆中的内存都是拷贝的线程的栈中才能进行使用的

![JMM内存结构示意图](https://upload-images.jianshu.io/upload_images/15168036-12ead20bc89a8e9b.png)

### javajava多线程的特性

1.  具有不同的阻塞(Block)类型 等待阻塞 锁定阻塞 IO阻塞
2.  多种多样的锁机制

## 线程安全问题

要保证线程安全就要考虑以下3个特性

1.  原子性 在java中主要是锁机制 可以用原语或其他机制实现
2.  可见性 volatile **脏读问题**
3.  有序性 happen-before原子

## 如何创建线程

```java
// 创建线程的方法
// 0.继承Thread类
// 1.实现Runnable接口 简单实现run方法 
Thread(()->{System.out.print(Thread.currentThread().getName())}).start()
// 2.实现Callable接口 这个和后面线程池相关简单讲下
// Callable优势在于执行之后可以返回值 Runable不行 call()可以抛出异常run()不行
// Callable对象拿到一个Future对象获得线程执行结果
```

## java线程的状态以及其他方法

---

![线程状态](https://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg)

一共有五中状态 可执行(Runnable) 正在执行(Running) 

***Block(普通阻塞) 等待Block(wait) 锁定Blocked(synchronized)***

```java
Thread.start() 
// 加入jvm等待执行队列 并不会立即执行 等待main线程执行结束之后
// 想要立刻执行可以参考下面的join方法
Thread.yield() // 让步 放入就绪队列队尾 要慎重使用 因为有准备时间 所以实际是running一会在回到就绪队列的慎用
Thread.sleep() // 计时阻塞

synchronized(this){ // 得和在同步代码块中使用 获得类的对象或者实例的对象
Object.wait() 
// 进入和该对象有关的等待区域 释放锁对象 可传入参数 在参数的时间结束后开始等待
// 相比于sleep 不需要进行异常捕获
// 可带参数 100 意味着100ms之后可以被notify
// 但其实释放的是持有该对象的线程的对象的锁 这是其本质
// 只不过在main线程中 看起来就像只是释放了锁而已
// 注意注意 因为wait是native方法 只与使用该对象的线程有关 与调用对象无关

 
Object.notify() Object.notifyAll() // 唤醒同步
}
```

```java
// wait notify 实现先后执行 在同一个类内
// wait notify 都是由Object对象进行调用 并不是传统的对象
int i = 0; // 共享数据 mutex
public void fun1(){
  synchronized(this){ // 获得当前对象的锁(使用权)
    if(i==0){
      // 操作1
    }
    i = 1;
    this.notifyAll(); // 通知其他持有该对象锁(使用权)的线程可以使用该对象了
  }
  // 释放了对象的锁
}
public void fun2(){
  synchronized(this){
    if(i!=0){
    	this.wait(); // 该线程等待其他线程使用 释放锁(使用权)
    }
  }
}
```

```java
Thread.join()	// 阻塞 如果刚创建就执行阻塞则会中断主线程的执行
// 从上面图中我们可以看出 这个是可以让线程从运行状态变成阻塞状态的
// 也可以让阻塞状态的线程变成等待状态
// 我们看下其源码实现
  /**
     *  Waits at most <code>millis</code> milliseconds for this thread to  
     * die. A timeout of <code>0</code> means to wait forever.    
     */

  public final synchronized void join(long millis) throws InterruptedException{
  long base = System.currentTimeMillis();
  long now = 0;

  if (millis < 0) {
    throw new IllegalArgumentException("timeout value is negative");
  }

  if (millis == 0) {
    while (isAlive()) { // 如果该线程还活着的话
      wait(0); 
			// 因为是定义在Object里面的相当于this.getClass().wait()
      // 别看这里是线程对象 实际上是运行着该对象的线程的wait其他
      // 虽然毫无疑问的虽然this是当前正在运行的线程对象
      // 但是获得的确是this所指代对象的锁
      // 等待其他拥有该对象的线程notify
    }
  } else {
    while (isAlive()) {
      long delay = millis - now;
      if (delay <= 0) {
        break;
      }
      wait(delay);// 本质是叫其他线程等待 多了一冲线程是否活着的判断而已
      now = System.currentTimeMillis() - base;
    }
  }
}
```

## 基本线程执行方式

main函数本质上就是一个线程 而非进程 进程可视作jvm管理资源

每个线程执行之后会释放自己的锁 同时this.notifyAll() 此处this指代线程对象

也就是说 释放本线程对象的锁(释放资源) 其他线程如果有等待该线程则会被notifyAll通知到

## 锁

---

说是锁其实理解为某一对象的使用权更加合适 我们从上面代码中已经看出来 锁就是一个对象的使用权 synchronized关键字配合wait notify一起使用 可以完成对象制约线程

## ***synchronized关键字***

---

synchronized 关键字时java多线程中比较重要的东西 其可以实现原子性和可见性 可用于代替下面的volatile关键字

synchronized 保证代码块或者方法在运行时 同一时刻只有一个对象可以进入到临界区，同时它还可以保证共享变量的内存可见性

1.  ### 普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁

2.  ### 静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁

3.  ### 同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

简单点来讲就是 我们想阻断i++交替访问 直接在方法上加锁就可以了

### 普通方法加synchronized关键字

```java
public class synctest extends Thread{
    static int im = 0;

    @Override
    public synchronized void run() {
        for (int i = 0; i < 10000; ++i) {
            im++;
        }
      	System.out.println(im); 
      // 最后输出结果不是20000 但加上sync关键字后就变成了20000
      // 其原因就在于对对象加了锁 意味着只有一个对象能调用此函数
      // 我们也可以对static加锁 那就是对Class的对象加锁 一个
    }

    public static void main(String[] args) throws InterruptedException {
        synctest s1=new synctest();
        Thread t1 = new Thread(s1);
      	Thread t2 = new Thread(s1); // 因为是普通方法所以引用得一样
        s1.start();
        s2.start();
    }
}
```

如果一个类中有两个不同的同步方法 必须等待其中一个执行完之后才能执行第二个

因为虽然说都是同一个类的不同方法但都获取了对象的锁 所以没办法实现 并发

这个就体现出该关键字设计的臃肿了 当然 也只有同步方法会要求锁 普通方法还是随意使用

**所以普通方法的关键点就是获取实例对象的锁 相同实例对象持有相同的锁 不同实例对象持有不同的锁**

### 静态方法加synchronized关键字

```java
public static void main(String[] args) throws InterruptedException {        
  Thread t2 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  Thread t1 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  t1.start();
  t2.start();
  t1.join(); // 主线程进入等待/阻塞 子线程开始执行 
  t2.join(); // 主线程进入等待 子线程开始执行
  System.out.println(stMethodTest.i); 
  // 不会是20000 而加上sync关键字之后 只要是调用该(同一)类的方法(不是对象)就
  // 就会被阻塞 直到前一个类退出临界区为止
}
class stMethodTest{
    static int i=0;
    static void ins(){
        i++;
    }
}
```

可以看见 其因为持有类对象的锁所以并发性进一步减小 显得臃肿

### 同步代码块

如果在一个大方法内执行全部同步代码显得操作及其耗时耗力 所以只用一小部分代码完成同步就可以实现并发了 基于这个思想 java有了同步代码快的机制 其可以写在方法里

```java
public void run(){
  synchronized(this){ // 作用域该对象 可以视为对普通方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
public void run(){
  synchronized(this.getClass()){ // 作用域该类 可以视为对静态方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
```

## volatile关键字(脏读)

其本质的实现保证的线程安全 主要实现的原理是 主内存(进程堆中的值立刻更新) 而不是更新堆栈的值 其保证了一个变量的可见性(能够立即读取更新值)

可以用于解决脏读问题 但不可解决原子性问题所以依然可能会发生线程安全问题

```java
public class threadstest3 extends Thread{
    /**
     * 测试volatile关键字可读性
     * */
    boolean flag = false; 
  	// 不加关键字时 死循环依然在执行
 		// 加了关键字之后
    int i = 0;
    @Override
    public void run() {
        while (!flag) {
            i++;
        }
    }

    public static void main(String[] args) throws Exception {
        threadstest3 vt = new threadstest3();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println("stop at " + vt.i);
    }
}
```

而保证了可见性并不代表是线程安全的 如下就是一个例子 如果操作不是原子性线程依然不安全

```java
package com.test.sync;

public class threadstest2 {
    /**
     * 证明了volatile破除了关键字 不一定能保证线程安全
     */

    public static void main(String[] args)throws Exception{
        TestClass tc = new TestClass();
        for (int i = 0; i < 1000; i++) {
            tc.startThread();
        }
    }
}

class TestClass {
    volatile Integer count = 0;
    // 不加关键字的时候 最后输出的结构随机
    // 加了关键字之后 依然没有能够完全按照我们的逻辑去执行
    // 其原因就是volatile只是线程间可见 但如果操作不是原子性的话依然有可能出错

    public void startThread() throws Exception{
        new Thread(() -> {
            count++;
            System.out.println(count);
        }).start();
    }
}
```

![JMM内存结构示意图](https://upload-images.jianshu.io/upload_images/15168036-12ead20bc89a8e9b.png)

回顾JMM的结构以及代码执行时候的结果 volatile关键字的现象是比较难以看见的

那么本地内存的变量缓存是何时刷新到主内存里取得呢?

```note
In essence, releasing a lock forces a flush of all writes from working memory employed by the thread, and acquiring a lock forces a (re)load of the values of accessible fields. While lock actions provide exclusion only for the operations performed within a synchronized method or block, these memory effects are defined to cover all fields used by the thread performing the action.
```

当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来.

而我们常见的System.out.println()方法是一个同步方法 所以有获得锁会刷新内存

这就给了我们一个最基本的启示 尽量使用调试器去观察变量的值 而不是打印 因为打印会刷新缓存

## 实现基本的同步问题

### 生产者消费者

### 读者写者

## 线程池的使用

## ***happen-before原则***

**它真正的意思是前面的操作对后续的操作都是可见的 可见意味着结果按执行先后的顺序可以确定下来 但是执行顺序却未必如同我们意料中的那样**

现代编译器为了提高性能经常对指令进行重排序

重排序分为编译优化重排序,指令并行重排序,内存系统重排序.

**happen-before是jmm维护的内存关系用于保证可见性** 

A线程的读和B线程的写如果之间存在happen-before关系那么就保证了B的写对A的读可见,也一定意味着B的写在A之前执行,但是两个操作之间存在happens-before关系,并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行.如果重排序之后的执行结果,与按happens-before关系来执行的结果一致,那么这种重排序并不非法（也就是说，JMM允许这种重排序）

### 程序的顺序性规则

​	一个线程中的每个操作，happens-before于该线程中的任意后续操作

### ***监视器锁规则***

​	对一个锁的解锁(释放锁),happens-before于随后对这个锁的加锁(获得锁).

### ***volatile变量规则***

对一个volatile域的写,happens-before于任意后续对这个volatile域的读.

### 传递性

A happens-before B,且B happens-before C,那么A happens-before C

### ***start()规则***

如果线程A执行操作ThreadB.start() (启动线程B),那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作

### ***Join()规则***

如果线程A执行操作ThreadB.join()并成功返回,那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

### 程序中断规则

对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生

### 对象finalize规则

一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始

### 利用上面的规则通过传递性等可以确定结果,但不一定可确定执行顺序

## ThreadLocal



## 原子性相关

除了上述用synchronized 关键字和锁机制实现原子性之外 还可以通过CAS机制 信号量机制等

赋值操作并不一定是原子操作 如果32位机子用64位变量cpu还要两次才能完成赋值操作

大多数情况下 赋值操作是原子性操作

java中有一些类是可原子性操作的AtomicInteger,AtomicLong,AtomicBoolean

他们都是通过CAS完成原子性的

### CAS

Compare and Swap 三个参数内存值V 旧的期望值A 新的期望值B

当A=V时 把V修改为B 否则什么也不做 如下伪代码

是一种无锁算法

伪代码如下

```note
do{
	备份旧数据;
	基于旧数据构造新数据; // 计算
}while(!CAS( 内存地址，备份的旧数据，新数据 ))
这个循环的运行结果只有一种情况 
其思想相当简单 如果旧数据被改那么我重新再执行一遍计算
如果没被改 我就能把计算的值放到里面去 
由于CAS 只用执行一条CPU指令所以其为原子性操作(当然也有很特殊的情况默认为是原子性)
```

## synchronized关键字的实现原理

jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

jvm首先看方法表中有没有同步方法 如果有 那么则令线程现持有monitor(管程) 在方法执行完后的时候释放monitor 这是隐式的实现 不利用到字节码

代码块的同步是利用monitorenter和monitorexit这两个字节码指令 其实所谓的锁就是一个程序计数器 有多少程序进入其中就加1或者减1

而monitor的本质是基于mutex 实现的互斥  // 大写的卧槽 

称此种依赖mutex实现的锁为重量锁

java1.6引入了偏向锁的机制一共有4种状态,级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态 锁可以升级但不能降级

偏向锁的获取：

判断是否为可偏向状态
如果为可偏向状态，则判断线程ID是否是当前线程，如果是进入同步块；
如果线程ID并未指向当前线程，利用CAS操作竞争锁，如果竞争成功，将Mark Word中线程ID更新为当前线程ID，进入同步块
如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活动状态，决定是转换为无锁状态还是升级为轻量级锁。

