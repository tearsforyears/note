# 多线程

---

[TOC]

## 文档使用说明

---

写于2020 java的多线程机制相对复杂 前提是了解JVM的加载过程 理解此中机制实现会比较好一点 其认知的机制请按照以下顺序来会比较好 该文档写的相对不那么离散 但因为曾经有过多线程的编程经验而非纯粹的开始 更像review而不像guide 请按顺序阅读 需要面向对象的基础 jvm的基础可以直接开始阅读本文档

本文档从内存说起 多线程涉及线程安全问题 内存屏障等机制的存在也是为了解决多线程问题

---

## JVM内存模型

---

稍微一提jvm的内存结构

**heap 用于存放process级别数据** class内的变量等 new 出来的变量等 数组等

**stack 存放thread/function级别数据** 局部变量操作数栈动态链接方法出口

**方法区 process级数据** 常量池 static变量区 类接口等加载去

**navtive 方法区 global级别数据** 被jvm环境使用 存放c++实现的方法 主要针对字节码操作

## JMM内存模型

---

即多线程下内存模型 java memory model 我们要研究的主体为线程堆栈(thread stack)

### 线程栈Thread Stack

线程栈对于其他线程是不可见的,包含了线程的局部变量等

进程的栈和线程的栈也是不互通的 只有堆中的局部变量能够进行互相访问

而且堆中的内存都是拷贝的线程的栈中才能进行使用的

![JMM内存结构示意图](https://upload-images.jianshu.io/upload_images/15168036-12ead20bc89a8e9b.png)

### java多线程的特性

1.  具有不同的阻塞(Block)类型 等待阻塞 锁定阻塞 IO阻塞
2.  多种多样的锁机制

## 线程安全集合

collections中的数据结构例如hashtable vector之类的是线程安全的 但是其实现的时候是通过锁住操作来完成的 效率低下 而concurrent包中的线程对此进行了改进 故优先使用

| interface | non-thread-safe         | concurrent-thread-safe                   | collections-thread-safe |
| --------- | ----------------------- | ---------------------------------------- | ----------------------- |
| List      | ArrayList               | CopyOnWriteArrayList                     | Vector(弃用)            |
| Map       | HashMap                 | ConcurrentHashMap                        | HashTable(弃用)         |
| Set       | HashSet / TreeSet       | CopyOnWriteArraySet                      |                         |
| Queue     | ArrayDeque / LinkedList | ArrayBlockingQueue / LinkedBlockingQueue |                         |
| Deque     | ArrayDeque / LinkedList | LinkedBlockingDeque                      |                         |

## 线程安全问题

要保证线程安全就要考虑以下3个特性

1.  原子性 在java中主要是锁机制 可以用原语或其他机制实现
2.  可见性 volatile **脏读问题**
3.  有序性 happen-before原子

## 如何创建线程

```java
new Thread(()->{System.out.print(Thread.currentThread().getName())}).start();
```

### 1.继承Thread类

### 2.实现Runnable接口

### 3.线程池的execute和submit

### 4.关于Runnable和Callable

两者都是用于实现任务的接口 不同的是Runnable接口为没有返回值的接口 对应线程池中的execute方法 而Callable是有返回值的方法 通过拿到future对象可以获取返回值

另外值得一提的是Runnable接口的方法

## java线程的状态以及其他方法

---

![线程状态](https://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg)

一共有五中状态 可执行(Runnable) 正在执行(Running) 

### ***Block(普通阻塞) 等待Block(wait/notify) 锁定Blocked(synchronized)***

```java
Thread.start() 
// 加入jvm等待执行队列 并不会立即执行 等待main线程执行结束之后
// 想要立刻执行可以参考下面的join方法
Thread.yield() // 让步 放入就绪队列队尾 要慎重使用 因为有准备时间 所以实际是running一会在回到就绪队列的慎用
Thread.sleep() // 计时阻塞

synchronized(this){ // 得和在同步代码块中使用 获得类的对象或者实例的对象
Object.wait() 
// 进入和该对象有关的等待区域 释放锁对象 可传入参数 在参数的时间结束后开始等待
// 相比于sleep 不需要进行异常捕获
// 可带参数 100 意味着100ms之后可以被notify
// 但其实释放的是持有该对象的线程的对象的锁 这是其本质
// 只不过在main线程中 看起来就像只是释放了锁而已
// 注意注意 因为wait是native方法 只与使用该对象的线程有关 与调用对象无关

 
Object.notify() Object.notifyAll() // 唤醒同步
}
```

```java
// wait notify 实现先后执行 在同一个类内
// wait notify 都是由Object对象进行调用 并不是传统的对象
int i = 0; // 共享数据 mutex
public void fun1(){
  synchronized(this){ // 获得当前对象的锁(使用权)
    if(i==0){
      // 操作1
    }
    i = 1;
    this.notifyAll(); // 通知其他持有该对象锁(使用权)的线程可以使用该对象了
  }
  // 释放了对象的锁
}
public void fun2(){
  synchronized(this){
    if(i!=0){
    	this.wait(); // 该线程等待其他线程使用 释放锁(使用权)
    }
  }
}
```

```java
Thread.join()	// 阻塞 如果刚创建就执行阻塞则会中断主线程的执行
// 从上面图中我们可以看出 这个是可以让线程从运行状态变成阻塞状态的
// 也可以让阻塞状态的线程变成等待状态
// 我们看下其源码实现
  /**
     *  Waits at most <code>millis</code> milliseconds for this thread to  
     * die. A timeout of <code>0</code> means to wait forever.    
     */

  public final synchronized void join(long millis) throws InterruptedException{
  long base = System.currentTimeMillis();
  long now = 0;

  if (millis < 0) {
    throw new IllegalArgumentException("timeout value is negative");
  }

  if (millis == 0) {
    while (isAlive()) { // 如果该线程还活着的话
      wait(0); 
			// 因为是定义在Object里面的相当于this.getClass().wait()
      // 别看这里是线程对象 实际上是运行着该对象的线程的wait其他
      // 虽然毫无疑问的虽然this是当前正在运行的线程对象
      // 但是获得的确是this所指代对象的锁
      // 等待其他拥有该对象的线程notify
    }
  } else {
    while (isAlive()) {
      long delay = millis - now;
      if (delay <= 0) {
        break;
      }
      wait(delay);// 本质是叫其他线程等待 多了一冲线程是否活着的判断而已
      now = System.currentTimeMillis() - base;
    }
  }
}
```

## 基本线程执行方式

main函数本质上就是一个线程 而非进程 进程可视作jvm管理资源

每个线程执行之后会释放自己的锁 同时this.notifyAll() 此处this指代线程对象

也就是说 释放本线程对象的锁(释放资源) 其他线程如果有等待该线程则会被notifyAll通知到

## ***synchronized关键字***

---

synchronized 关键字时java多线程中比较重要的东西 其可以实现原子性和可见性 可用于代替下面的volatile关键字

synchronized 保证代码块或者方法在运行时 同一时刻**只有一个对象(不是一个线程)可以进入到临界区**，同时它还可以保证共享变量的内存可见性

我们说的加了线程获取了对象的锁(使用权) 持有该对象的其他线程必须等待,synchronized关键字只是把对象的锁注入进了当前线程中仅此而已

1.  ### 普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁

2.  ### 静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁

3.  ### 同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

简单点来讲就是 我们想阻断i++交替访问 直接在方法上加锁就可以了

### 普通方法加synchronized关键字

```java
public class synctest extends Thread{
    static int im = 0;

    @Override
    public synchronized void run() {
        for (int i = 0; i < 10000; ++i) {
            im++;
        }
      	System.out.println(im); 
      // 最后输出结果不是20000 但加上sync关键字后就变成了20000
      // 其原因就在于对对象加了锁 意味着只有一个对象能调用此函数
      // 我们也可以对static加锁 那就是对Class的对象加锁 一个
    }

    public static void main(String[] args) throws InterruptedException {
        synctest s1=new synctest();
        Thread t1 = new Thread(s1);
      	Thread t2 = new Thread(s1); // 因为是普通方法所以引用得一样
        s1.start();
        s2.start();
    }
}
```

如果一个类中有两个不同的同步方法 必须等待其中一个执行完之后才能执行第二个

因为虽然说都是同一个类的不同方法但都获取了对象的锁 所以没办法实现 并发

这个就体现出该关键字设计的臃肿了 当然 也只有同步方法会要求锁 普通方法还是随意使用

**所以普通方法的关键点就是获取实例对象的锁 相同实例对象持有相同的锁 不同实例对象持有不同的锁**

### 静态方法加synchronized关键字

```java
public static void main(String[] args) throws InterruptedException {        
  Thread t2 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  Thread t1 = new Thread(()->{
    for (int i = 0; i < 10000; i++) {
      stMethodTest.ins();
    }
  });
  t1.start();
  t2.start();
  t1.join(); // 主线程进入等待/阻塞 子线程开始执行 
  t2.join(); // 主线程进入等待 子线程开始执行
  System.out.println(stMethodTest.i); 
  // 不会是20000 而加上sync关键字之后 只要是调用该(同一)类的方法(不是对象)就
  // 就会被阻塞 直到前一个类退出临界区为止
}
class stMethodTest{
    static int i=0;
    static void ins(){
        i++;
    }
}
```

可以看见 其因为持有类对象的锁所以并发性进一步减小 显得臃肿

### 同步代码块

如果在一个大方法内执行全部同步代码显得操作及其耗时耗力 所以只用一小部分代码完成同步就可以实现并发了 基于这个思想 java有了同步代码快的机制 其可以写在方法里

```java
public void run(){
  synchronized(this){ // 作用域该对象 可以视为对普通方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
public void run(){
  synchronized(this.getClass()){ // 作用域该类 可以视为对静态方法进行同步
    for(int j=0;j<10000;j++){
      i++;
    }
  }
}
```

## volatile关键字(脏读)

其本质的实现保证的线程安全 主要实现的原理是 主内存(进程堆中的值立刻更新) 而不是更新堆栈的值 其保证了一个变量的可见性(能够立即读取更新值)

可以用于解决脏读问题 但不可解决原子性问题所以依然可能会发生线程安全问题

```java
public class threadstest3 extends Thread{
    /**
     * 测试volatile关键字可读性
     * */
    boolean flag = false; 
  	// 不加关键字时 死循环依然在执行
 		// 加了关键字之后
    int i = 0;
    @Override
    public void run() {
        while (!flag) {
            i++;
        }
    }

    public static void main(String[] args) throws Exception {
        threadstest3 vt = new threadstest3();
        vt.start();
        Thread.sleep(2000);
        vt.flag = true;
        System.out.println("stop at " + vt.i);
    }
}
```

而保证了可见性并不代表是线程安全的 如下就是一个例子 如果操作不是原子性线程依然不安全

```java
package com.test.sync;

public class threadstest2 {
    /**
     * 证明了volatile破除了关键字 不一定能保证线程安全
     */

    public static void main(String[] args)throws Exception{
        TestClass tc = new TestClass();
        for (int i = 0; i < 1000; i++) {
            tc.startThread();
        }
    }
}

class TestClass {
    volatile Integer count = 0;
    // 不加关键字的时候 最后输出的结构随机
    // 加了关键字之后 依然没有能够完全按照我们的逻辑去执行
    // 其原因就是volatile只是线程间可见 但如果操作不是原子性的话依然有可能出错

    public void startThread() throws Exception{
        new Thread(() -> {
            count++;
            System.out.println(count);
        }).start();
    }
}
```

![JMM内存结构示意图](https://upload-images.jianshu.io/upload_images/15168036-12ead20bc89a8e9b.png)

回顾JMM的结构以及代码执行时候的结果 volatile关键字的现象是比较难以看见的

那么本地内存的变量缓存是何时刷新到主内存里取得呢?

```note
In essence, releasing a lock forces a flush of all writes from working memory employed by the thread, and acquiring a lock forces a (re)load of the values of accessible fields. While lock actions provide exclusion only for the operations performed within a synchronized method or block, these memory effects are defined to cover all fields used by the thread performing the action.
```

当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来.

而我们常见的System.out.println()方法是一个同步方法 所以有获得锁会刷新内存

这就给了我们一个最基本的启示 尽量使用调试器去观察变量的值 而不是打印 因为打印会刷新缓存

## 锁

---

说是锁其实理解为某一对象的使用权更加合适 我们从上面代码中已经看出来 锁就是一个对象的使用权 synchronized关键字配合wait notify一起使用 可以完成对象制约线程

java.util.concurrent 是一个解决线程安全问题的包 里面是一些并发操作并提供了Lock接口供显示锁的使用

### 独占锁synchronized

前面锁讲的synchronized就是一种独占锁 加锁和解锁的过程都需要 其实一种隐式锁

### 可重入锁ReentrantLock

其可以实现公平锁机制, 即哪个线程等待越长 优先相应等待久的线程

```java
Lock lock = new ReentrantLock(); // 传入true就行
lock.lock(); // 加锁
try{
    //临界区......
}finally{
    lock.unlock(); // 解锁
}
```

重入锁是可以对一个线程加多次锁,但是相应的也要解锁多次

### 通知机制Condition

synchronized 和wait,notify可以实现通知线程的机制

ReentrantLock和Condition可实现一样的机制

```java
class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();
    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
// 除此之外await还有如下形式 1s 之后没人通知自己醒来
condition.await(1, TimeUnit.SECOND);
```

### 读写锁(悲观锁) ReadWriteLock

就是为了解决读者写者问题的 允许一个线程写 多个线程读 且读写分离 即只能读或者写

```java
public class Counter {
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];
    public void inc(int index) { // 写操作
        wlock.lock(); // 加写锁
        try {
            counts[index] += 1;
        } finally {
            wlock.unlock(); // 释放写锁
        }
    }
    public int[] get() { // 读操作
        rlock.lock(); // 加读锁
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            rlock.unlock(); // 释放读锁
        }
    }
```

### 读写锁(乐观锁) StampedLock

相比于悲观锁 其默认为为读的时候大概率不会有写入 所以我们需要判定有没有写入的线程在读

或者直接实现CAS机制用于线程间的同步

```java
public class Point {
    private final StampedLock stampedLock = new StampedLock();
    private double x;
    private double y;
    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }
    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```



---

## 实现基本的同步问题

生产者消费者问题和读者写者问题 一个直接映射着消息队列的设置 另一个直接关系到集群的读写分离模型设计问题 故单独作为讨论

### 生产者消费者

本质上就一个东西 生产者消费者共用一把锁就不会出现问题 要么只能生产要么只能消费

解决思路就是同一把锁一起使用就是了

```java
package com.test.sync;

import java.util.*;

public class Test {
    static Object lock = new Object();
    static int[] array = new int[10];

    static Integer count = 0;
    static {
        for (int i = 0; i < array.length; i++) {
            array[i] = -1;
            // 非法值填充
        }
    }

    public static void main(String[] args) {
        new Thread(()->{
            try {
                while(true) {
                    set();
                    Thread.sleep(90);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(()->{
            try {
                while(true) {
                    get();
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


    }
    public static void get() throws InterruptedException {
        synchronized (lock) {
            while(count<1){
              	// 为什么这里不用if用while 是因为阻塞的时候 回来执行的时候如果是if
              	// 那么就会执行get an element操作 而while的话 回来继续判断
              	// 不符合条件在次释放锁
                lock.wait();
            }
            // get an element
            for (int i = 0; i < array.length; i++) {
                if(array[i]!=-1) {
//                    System.out.println(array[i]);
                    array[i] = -1;
                    count--;
                    break;
                }
            }
            printArray(array);
            lock.notifyAll();
        }
    }
    public static void set() throws InterruptedException {
        synchronized (lock) {
            while(count>10){
                count.wait();
            }
            // set an element
            for (int i = 0; i < array.length; i++) {
                if(array[i]==-1) {
                    array[i] = rand();
                    count++;
                    break;
                }
            }
            printArray(array);
            lock.notifyAll();
        }
    }

    public static int rand() {
        return new Random().nextInt();
    }

    public static <T>void printArray(int[] array){
        System.out.print("[");
        for (int i = 0; i < array.length;i++){
            System.out.print(array[i]+",");
        }
        System.out.println("] count:"+count);
    }
}
```

### 读者写者

1.  允许多个读者同时执行读操作。 // 读者之前没有读者锁进行制约
2.  不允许读者、写者同时操作。 // 读写之间有公用锁进行制约
3.  不允许多个写者同时操作。 // 写者锁进行制约

这个设计思路就是两者之间用一把公共锁进行制约 然后读者有自己独立的锁就行

```java
package com.test.sync;

import java.util.Random;

public class testReaderWriter {
    final static Object readerLock = new Object();
    volatile static Integer writerCount = 0;
    final static Object writerLock = new Object();

    static Integer resource = -1;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    read();
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
            new Thread(() -> {
                try {
                    write();
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        Thread.sleep(0x2b67);

    }

    /**
     * 读者写者模式规则
     * 1.  允许多个读者同时执行读操作。 // 读者之前没有读者锁进行制约
     * 2.  不允许读者、写者同时操作。 // 读写之间有公用锁进行制约
     * 3.  不允许多个写者同时操作。 // 写者锁进行制约
     **/
    public static void read() throws InterruptedException {
        synchronized (readerLock) {
            while (writerCount > 0) {
                readerLock.wait();
            }
            System.out.println(Thread.currentThread().getName() + "read resource:" + resource);
        }
    }

    public static void write() throws InterruptedException {
        synchronized (readerLock) {
            // 读写同时只能有一个进入所以 写者也要获取读者的锁
            // 有写者在等待
            synchronized (writerLock) {
                // 写者之间进行互相制约
                while (writerCount > 0) {
                    writerLock.wait();
                }
                writerCount++;
                int i=rand();
                System.out.println(Thread.currentThread().getName() + "write resource:" + i);
                resource = i;
                writerCount--;
                writerLock.notifyAll();
            }
            readerLock.notifyAll();
        }
    }

    public static int rand() {
        return new Random().nextInt();
    }
}

```

## ***线程池的使用***

---

我们平时自己写线程的时候可能会造成不必要的开销,为了监控负载,更合理的调用资源

线程池有以下特点

1.  复用线程 控制最大并发数
2.  实现任务线程队列缓存策略和拒绝机制
3.  实现某些与时间相关的功能
4.  隔离线程环境

其优点在于

**降低资源消耗,提高响应速度,提高线程的可管理性**

其设计示意图如下

![设计示意图](https://images2018.cnblogs.com/blog/1425453/201807/1425453-20180729173817132-1865329285.jpg)

### 构造ThreadPoolExecutor

该类的和新方法是execute和addWorker

这个类是构造线程池用的,其间接继承了Excutor这个类,直接继承AbstractExcutorService

然后自定义**ThreadFactory**和**RejectedExecutionHandler**,其构造函数如下

```java
public ThreadPoolExecutor(int corePoolSize, // 核心(常驻)线程数
                          int maximumPoolSize, // 最大线程数
                          long keepAliveTime, // 线程失活时间
                          TimeUnit unit, // 线程失活单位
                          BlockingQueue<Runnable> workQueue, // 阻塞队列
                          ThreadFactory threadFactory, // 线程工厂
                          RejectedExecutionHandler handler) {
  if (corePoolSize < 0 ||
      maximumPoolSize <= 0 ||
      maximumPoolSize < corePoolSize ||
      keepAliveTime < 0)
    throw new IllegalArgumentException();
  if (workQueue == null || threadFactory == null || handler == null)
    throw new NullPointerException();
  this.acc = System.getSecurityManager() == null ?
    null :
  AccessController.getContext();
  this.corePoolSize = corePoolSize;
  this.maximumPoolSize = maximumPoolSize;
  this.workQueue = workQueue;
  this.keepAliveTime = unit.toNanos(keepAliveTime);
  this.threadFactory = threadFactory;
  this.handler = handler;
}
```

#### corePoolSize

核心线程数 如果为0则 则任务执行完之后 线程池关闭

如果不为0 则在执行完任务之后也不会销毁

过大会浪费资源 过小会频繁创建线程和加大资源开销

#### maximumPoolSize

最大并发数

#### keepAliveTime

空闲时间达到了keepAliveTime时,线程会被销毁 直到剩下corePoolSize为止

当线程池中线程数大于corePoolSize的时候keepAliveTime才起作用

也就是说 线程数常驻内存的只有corePoolSize个线程 其他的都有失活时间

#### unit

时间单位,通常是TimeUnit.SECONDS

#### workQueue

缓冲队列 像BlockingQueue和LinkedBlockingQueue,如果线程请求数大于maximumPoolSize则会进入缓冲队列进行阻塞,另外上面两个队列的入队和出队操作由锁机制保证了原子性

看类型参数里面是Runnable 如果是Callable需要加入到缓冲队列 会转换成Runnable类型

#### ***threadFactory***

它用来生产一组相同任务的线程,

#### handler

当workQueue的缓存区达到了上限的时候 我们可以拒绝线程的请求

这是一种简单的限流保护 这是请求的处理器

友好的拒绝策略如下

1.  保存到数据库进行削峰填谷;在空闲时再提取出来执行
2.  转向某个提示页面
3.  打印日志

默认策略是 AbortPolicy 则是对其任务直接抛弃并抛出异常

CallerRunsPolicy:只用提交任务所在线程来运行任务,有反馈机制,使任务提交的速度变慢

DiscardOldestPolicy:若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务

DiscardPolicy:不处理,丢弃掉,拒绝执行,不抛异常

自定义拒绝策略可以通过实现RejectedExecutionHandler实现reject(),例如日志持久化

### 简单使用

```java
ExecutorService service = new ThreadPoolExecutor(8, 16, 8, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
```

我们可以通过execcute方法或者submit方法向线程池提交任务,其后面的代码把其封装成一个Worker加入到Workers里面去 Worker是对线程的封装,线程池内部使用一个Set存储worker不会使得worker重复 `HashSet<Worker> workers=new HashSet<>();`

线程会重阻塞队列workQueue中poll()取出任务放到核心线程中去执行

#### execute 方法

该方法没有返回值所以无法确定有没有执行成功

```java
service.execute(new Runnable() {
  public void run() {
    System.out.println("提交任务");
  }
});
```

其内部是如果核心线程空闲addIfUnderCorePollSize

#### submit方法

该方法针对的是Callable对象

```java
Future<Integer> future = service.submit(new Callable<Integer>() {
  @Override
  public Integer call() throws Exception {
    System.out.println("submit方式");
    return 2;
  }
});
try {
  Integer number = future.get();
} catch (ExecutionException e) {
  // TODO Auto-generated catch block
  e.printStackTrace();
}
```

#### Future/FutureTask类的使用

```java
// 原生使用
// 我们假设这个线程要返回一个integer
Callable<Integer> thread = new Callable<Integer>() {
  @Override
  public Integer call() throws Exception {
    System.out.println(Thread.currentThread().getName() + " execute");
    return 3;
  }
};
// FutureTask 实现了 Future接口
Future<Integer> ft = new FutureTask<>(thread);
new Thread(ft).start();
long start = System.currentTimeMillis();
// 卡着 等虚拟机调度
while (!ft.isDone()) { // 可以用while(ft.isDone()){} 等待线程执行结束
  System.out.println("线程没执行结束 等着");
}
// ft.get(); // 这句话也可以直接阻塞等待线程执行结束
long end = System.currentTimeMillis();
Integer i = ft.get(); // 获取返回值
System.out.println(i + "系统调度用时" + (end - start) + "ms");
```

#### shutdown方法

.shutdown(); .shutdownNow(); // 两个方法上用于关闭线程池

shutdown(); // 线程不能接受新的任务 会等待当前线程执行结束

shutdownNow(); // 线程不能接受新的任务并且尝试终止现在的任务

#### 线程池运行状态监测

```java
pool.getPoolSize();
pool.getQueue().size(); // 等待队列的线程数目
pool.getCompletedTaskCount() // 已经完成的线程数
```

#### 线程池状态

线程池状态是线程池处于何种阶段的内部描述volatile runState

RUNNING,SHUTDOWN,STOP,TERMINATED

SHUTDOWN:调用shutdown后,线程池不能接受新任务,等待线程执行完成

STOP:调用shutdownNow后,线程池不能接受新任务,并尝试销毁其他任务

TERMINATED:当工作线程已经销毁,任务缓冲队列清空或执行结束之后

**队列、线程工厂、拒绝处理服务**都必须有实例对象,但编程中我们很少亲自实例化对象

```java
ExecutorService service = new ThreadPoolExecutor(8, 16, 8, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
```

这样子的代码 java内部配置了许多已经实现好的的线程池类

### 线程池的实现类

#### 固定线程池newFixedThreadPool

#### 缓存线程池newCachedThreadPool

#### 定时调度线程池newScheduledThreadPool

#### 单线程池newSingleThreadExecutor

```java
Executors.newFixedThreadPool(4); 
// 指定核心线程数和最大并发数为4 失活时间默认为0
// 此时失活时间无意义
// 也就是说不会开辟新的线程去执行任务,一共就4个线程自己轮询执行任务
Executors.newCachedThreadPool();
// 核心线程数为0 最大并发数为Integer.MAX_VALUE 失活时间为60秒
// 而且没有缓冲(阻塞)队列 也就是说以缓存形式执行线程 不会加入队列
// 现有线程池无法接收任务时,会创建新的线程去接受执行任务
Executors.newScheduledThreadPool(4); 
// 指定核心线程数为4 最大并发数为Integer.MAX_VALUE 失活时间为0
// 失活时间为0意味着额外的线程一旦执行结束就立刻被回收

ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
service.schedule(new Runnable() {
  public void run() {
    System.out.println(Thread.currentThread().getName()+"延迟三秒执行");
  }
}, 3, TimeUnit.SECONDS); // 延迟3秒
service.scheduleAtFixedRate(new Runnable() {
  public void run() {
    System.out.println(Thread.currentThread().getName()+"延迟三秒后每隔2秒执行");
  }
}, 3, 2, TimeUnit.SECONDS);

Executors.newSingleThreadExecutor();
// 核心线程和最大并发数都是1 失活时间为0
// 意味着所有该线程池执行的线程每次只有1个线程在运行 其他线程在等待
// 就是单线程模式 不会存在线程同步问题
```

### Excutors接口

这是线程池继承链顶端的接口 如下

![线程池的继承链](https://uploadfiles.nowcoder.com/files/20190118/7380095_1547784444679_4685968-eaaaf8fd88497757.png)

### 分布式计算相关

#### map-reduce核心方法的实现

```java
package com.test.sync;
import javafx.util.Pair;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;
public class _MapReduce {
    // 任务队列
    static List<Callable> mapTaskList = null;
    // 任务队列
    static List<Callable> reduceTaskList = null;
    // map结果集
    static List<Future> mapResultSet = null;
    // reduce结果集
    static List<Future> reduceResultSet = null;

    static ExecutorService mapPool = Executors.newCachedThreadPool();
    static ExecutorService reducePool = Executors.newCachedThreadPool();
    // 这里的线程池没有进行好的配置 只是为了说明测试的效果

    public static void main(String[] args) throws Exception {
        // init tasklist and resultset
        initComputeEnvironment();
        try {
            // 简单的计算
            _map(new Integer[]{1, 2, 3}, (i) -> {
                return i * 2;
            });
            printMapResultSet();
            clearList(mapResultSet);

            // 简单的单词分割任务
            _map(new String[]{"hi hello", "world wolf", "pig"}, (str) -> {
                return Arrays.asList(str.split(" "));
            });
            printMapResultSet();
            clearList(mapResultSet);

            Integer result = _reduce(new Integer[]{1, 3, 5, 7, 9}, (x, y) -> {
                return x * y;
            });
            System.out.println("reduce output:" + result);

            String _result = _reduce(new String[]{"1", "2", "3", "4", "5"}, (str1, str2) -> {
                return str1 + str2;
            });
            System.out.println("reduce output:" + _result);
        } finally {
            clearComputeEnvironment();
        }
    }

    public static List getResultSet(List<Future> resultSet) throws ExecutionException, InterruptedException {
        List ls = new ArrayList<>();
        for (Future f : resultSet) {
            ls.add(f.get());
        }
        return ls;
    }

    public static void printMapResultSet() throws ExecutionException, InterruptedException {
        System.out.print("map result:");
        for (Future f : mapResultSet) {
            System.out.print(f.get() + " ");
        }
        System.out.println();
    }

    public static void printReduceResultSet() throws ExecutionException, InterruptedException {
        System.out.print("after reduce:");
        long start = System.currentTimeMillis();
        for (Future f : reduceResultSet) {
            System.out.print(f.get() + " ");
        }
        System.out.println(System.currentTimeMillis() - start + "ms for execute");
    }

    public static void clearList(List ls) {
        ls.clear();
    }

    public static void initComputeEnvironment() {
        /**
         * 任务队列 CopyOnWriteArrayList
         */
        mapTaskList = new CopyOnWriteArrayList<>();
        mapResultSet = new CopyOnWriteArrayList<>();
        reduceTaskList = new CopyOnWriteArrayList<>();
        reduceResultSet = new CopyOnWriteArrayList<>();
    }

    public static void clearComputeEnvironment() {
        /**
         * 清空任务队列
         */
        mapTaskList.clear();
        mapResultSet.clear();
        reduceTaskList.clear();
        reduceResultSet.clear();
    }

    public static <I, O> void _map(I[] datas, Function<I, O> func) throws ExecutionException, InterruptedException {
        /**
         * 加入任务队列
         * 执行队列任务
         */
        add2TaskList(datas, func, mapTaskList);
        submitTask(mapTaskList, mapResultSet);
    }

    public static <I, O> I _reduce(I[] datas, BiFunction<I, I, O> func) throws ExecutionException, InterruptedException {
        /**
         * 加入任务队列
         */
        I[] ls = reduceTasks(datas, func);
        return ls[0];
    }

    // //
    public static <I, O> I[] reduceTasks(I[] datas, BiFunction<I, I, O> func) throws ExecutionException, InterruptedException {
        System.out.println("reduce debug: " + Arrays.asList(datas) + " length:" + datas.length);
        if (datas.length > 1) {
            boolean isOdd = false;
            if (datas.length % 2 != 0) { // 奇数个的时候进行特殊处理
                isOdd = true;
            }
            for (int i = 0; i < datas.length - 1; i += 2) {
                // 这个遍历是 奇数个的时候是没有最后一个数的 偶数个的时候是能完全遍历的
                int finalI = i;
                reduceTaskList.add(new Callable<O>() {
                    @Override
                    public O call() throws Exception {
                        return func.apply(datas[finalI], datas[finalI + 1]);
                    }
                });
            }
            submitTask(reduceTaskList, reduceResultSet); // 提交任务到线程池
            List resultList = getResultSet(reduceResultSet);
            if (isOdd) {
                resultList.add(datas[datas.length - 1]);
            }
            I[] resultSet = (I[]) resultList.toArray(); // 获得结果集
            clearList(reduceResultSet);
            clearList(reduceTaskList);
            return reduceTasks(resultSet, func);
        } else { // 等于1
            return datas;
        }
    }

    public static <I, O> void add2TaskList(I[] datas, Function<I, O> func, List<Callable> taskList) {
        for (I data : datas) {
            taskList.add(new Callable() {
                @Override
                public O call() throws Exception {
                    return func.apply(data);
                }
            });
        }
    }
    public static void submitTask(List<Callable> taskList, List<Future> resultSet) {
        /**
         * 提交任务到线程池中
         */
        if (taskList.size() < 1) {
            throw new RuntimeException("没有要执行的任务");
        } else {
            for (Callable c : taskList) {
                resultSet.add(mapPool.submit(c));
            }
        }
    }
}
```



#### ForkJoin

forkjoin是一个线程框架 如果任务足够小就进行计算 如果不够小就拆分成若干小任务进行计算

其思想和mapreduce有相像之处

***工作窃取模式***

当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，当没有任务执行时，再从一个随机线程的队列中偷一个并把它放在自己的队列中.相对于一般的线程池实现 ，fork/join 框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork/join 框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题（窃取过来）来执行，这种方式减少了线程的等待时间，提高了性能

Fork对应任务分解,Join对应任务合并,下面看一个并行求和的例子

其有缺点就是 瞬间内存需要特别大 而mapreduce并不需要那么高的内存

先定义一个类 继承 RecursiveTask 或者 RecursiveAction就行 不过后者不会返回结果

```java
class SumTask extends RecursiveTask<Long> { // 这个Long指的是返回值
    static final int THRESHOLD = 500;
    long[] array;
    int start;
    int end;

    SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // 如果任务足够小,直接计算:
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += this.array[i];
            }
            return sum;
        }
        // 任务太大,一分为二:
        int middle = (end + start) / 2;
      	// 直接调用内部类了
        SumTask subtask1 = new SumTask(this.array, start, middle);
        SumTask subtask2 = new SumTask(this.array, middle, end);
        invokeAll(subtask1, subtask2); 
      	// 这里并没有用到拆分
      	// subTask.fork() 拆分任务加入队列 默认拆分
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        Long result = subresult1 + subresult2; // 合并结果
        return result;
    }
}
```

计算调用

```java
// 求和数组为array
// fork/join:
ForkJoinTask<Long> task = new SumTask(array, 0, array.length);
long startTime = System.currentTimeMillis();
Long result = ForkJoinPool.commonPool().invoke(task);
long endTime = System.currentTimeMillis();
System.out.println("Fork/join sum: " + result + " in " + (endTime - startTime) + " ms.");
```

## ***happen-before原则***

---

**它真正的意思是前面的操作对后续的操作都是可见的 可见意味着结果按执行先后的顺序可以确定下来 但是执行顺序却未必如同我们意料中的那样**

现代编译器为了提高性能经常对指令进行重排序

重排序分为编译优化重排序,指令并行重排序,内存系统重排序.

**happen-before是jmm维护的内存关系用于保证可见性** 

A线程的读和B线程的写如果之间存在happen-before关系那么就保证了B的写对A的读可见,也一定意味着B的写在A之前执行,但是两个操作之间存在happens-before关系,并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行.如果重排序之后的执行结果,与按happens-before关系来执行的结果一致,那么这种重排序并不非法（也就是说，JMM允许这种重排序）

### 程序的顺序性规则

​	一个线程中的每个操作，happens-before于该线程中的任意后续操作

### ***监视器锁规则***

​	对一个锁的解锁(释放锁),happens-before于随后对这个锁的加锁(获得锁).

### ***volatile变量规则***

对一个volatile域的写,happens-before于任意后续对这个volatile域的读.

### 传递性

A happens-before B,且B happens-before C,那么A happens-before C

### ***start()规则***

如果线程A执行操作ThreadB.start() (启动线程B),那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作

### ***Join()规则***

如果线程A执行操作ThreadB.join()并成功返回,那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

### 程序中断规则

对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生

### 对象finalize规则

一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始

### 利用上面的规则通过传递性等可以确定结果,但不一定可确定执行顺序

## ThreadLocal

---

ThreadLocal 为每个线程提供了一个独立的变量副本去解决线程并发冲突问题,在很多情况下,ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单,更方便,且结果程序拥有更高的并发性

static变量放到ThreadLocal类型的对象中,使变量在每个线程中都有独立拷贝,不会出现一个线程读取变量时而被另一个线程修改的现象

本质上ThreadLocal 是对Thread 的**threadLocals属性(类型为ThreadLocalMap)**进行管理

其实其作用为隔离线程之间的共享变量,为每个线程创建一个副本

ThreadLocal中的方法

```java
public T get();
public void set(T value);
public void remove(); // 清楚
protected T initialValue();
```

```java
private static final ThreadLocal<String> tl = new ThreadLocal<String> ();

public static void main(String[] args) throws InterruptedException {
  Thread t1 = new Thread(()->{
    System.out.println(tl.get());
    tl.set("444");
    System.out.println(tl.get());
  });
  Thread t2 = new Thread(()->{
    System.out.println(tl.get());
    tl.set("333");
    System.out.println(tl.get());
  });
  t1.start();
  t1.join();
  t2.start();
}
```

从web的角度来看 **ThreadLocal ，将其与当前线程绑定** 可以直接从preHandler中就完成值的保存而不是依赖request对象进行保存,ThreadLocal 是要针对线程的全局变量的隔离,并非对域内进行隔离

ThreadLoaclMap<K,V>中 K就是线程的弱引用,而V就是我们设置值得强引用

其可能存在一些内存泄漏问题 如果创建的线程是堆entry的强引用(比如static) 那么就不能被GC 长期下来就有可能导致内存泄漏

---

## 其他相关技术

除了上述用synchronized 关键字和锁机制实现原子性之外 还可以通过CAS机制 信号量机制等

赋值操作并不一定是原子操作 如果32位机子用64位变量cpu还要两次才能完成赋值操作

大多数情况下 赋值操作是原子性操作

java中有一些类是可原子性操作的AtomicInteger,AtomicLong,AtomicBoolean

他们都是通过CAS完成原子性的

### CAS原子性保证

Compare and Swap 三个参数内存值V 旧的期望值A 新的期望值B

当A=V时 把V修改为B 否则什么也不做 如下伪代码

是一种无锁算法

伪代码如下

```note
do{
	备份旧数据;
	基于旧数据构造新数据; // 计算
}while(!CAS( 内存地址，备份的旧数据，新数据 ))
这个循环的运行结果只有一种情况 
其思想相当简单 如果旧数据被改那么我重新再执行一遍计算
如果没被改 我就能把计算的值放到里面去 
由于CAS 只用执行一条CPU指令所以其为原子性操作(当然也有很特殊的情况默认为是原子性)
```

### AQS 队列同步器

AbstractQueuedSynchronizer 队列同步器 后续冲

## synchronized关键字的实现原理

jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

jvm首先看方法表中有没有同步方法 如果有 那么则令线程现持有monitor(管程) 在方法执行完后的时候释放monitor 这是隐式的实现 不利用到字节码

代码块的同步是利用monitorenter和monitorexit这两个字节码指令 其实所谓的锁就是一个程序计数器 有多少程序进入其中就加1或者减1

而monitor的本质是基于mutex 实现的互斥  // 大写的卧槽 

称此种依赖mutex实现的锁为重量锁

java1.6引入了偏向锁的机制一共有4种状态,级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态 锁可以升级但不能降级

偏向锁的获取：

判断是否为可偏向状态
如果为可偏向状态，则判断线程ID是否是当前线程，如果是进入同步块；
如果线程ID并未指向当前线程，利用CAS操作竞争锁，如果竞争成功，将Mark Word中线程ID更新为当前线程ID，进入同步块
如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活动状态，决定是转换为无锁状态还是升级为轻量级锁。

## 线程安全以及线程相关

### **1. Servlet对象是单实例多线程，Servlet不是线程安全的**

在非分布式的系统中,Servlet是单例多线程的,而且很显然没有锁去制约之中请求关系,单例意味着servlet容器只会生成一个servlet实例,只是对于每一个请求都调用service()方法去交给一个线程处理

如何解决Servlet的线程安全问题,synchronized代码块,线程安全的数据结构HashTable,BlockQueue等

### 2. Spring的bean是否是线程安全的

spring没有对bean进行多线程处理,但大多数情况下是无状态的(没有数据存储功能)那就不用去考虑线程安全的问题 如果是有状态 则需要去考虑Spring的线程安全问题

spring是默认单例模式 改成prototype则可以保证一定程度上的线程安全

再不成可以用ThreadLocal去保证线程安全问题