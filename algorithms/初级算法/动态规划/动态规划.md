
# 动态规划

[TOC]

## 一些基本问题

### 上楼梯问题

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

#### 上楼梯问题递归

```python
def f(n):
    if n==1:
        return 1
    if n==2:
        return 2
    return f(n-2)+f(n-1)

#print f(100)
```
#### 上楼梯问题改循环

```python
def f(n):
    lis = []
    for i in range(n):
        lis.append(-1)
    lis[0]=1
    lis[1]=2
    for i in range(2,n):
        lis[i]=lis[i-1]+lis[i-2]
    """制作哈希表完成"""
    return lis[n-1]
```

#### 上楼梯问题改dp

```python
def f(n):
  ifn==1:return 1;
  if n==2:return 2;
  count = -1;
  cur = 2;
  prev = 1;
  for i in range(n-2):
    count = cur + prev;
    prev = cur;
    cur = count;
  return count; 
```

上楼梯的状态转移方程`dp[i]`表示要第i层有多少中爬法

-   $$dp[i]=dp[i]+dp[i-1]$$

### 金矿问题/0-1背包问题

已经开另一文档去解读0-1背包问题

有一个国家发现了5座金矿,每座金矿的黄金储量不同,需要参与挖掘的工人数也不同,参与挖矿工人的总数是10人.每座金矿要么全挖,要么不挖,不能派出一半人挖取一半金矿.要想得到尽可能多的黄金,应该选择挖取哪几座金矿?

| 金矿编号 | 黄金储量 | 需要人数 |
| :------- | :------- | :------- |
| 1        | 500      | 5        |
| 2        | 200      | 3        |
| 3        | 300      | 4        |
| 4        | 350      | 3        |
| 5        | 400      | 5        |

设置`dp[i][j]`表示用i个工人去挖前j座矿所获取的最大价值,那么最大价值无非就是挖或者不挖这座矿,所以我们很快能得到状态转移方程`P[j]`表示开发第j座矿需要的人数

-   $$dp[i][j]=max(dp[i][j-1],dp[i-P[j]][j-1]+G[j])$$

转换下i,j的含义,`d[i][j]`表示用j个工人去挖前i做金矿

对方程优化下优化下可以得到,这也可以算01背包问题的通解了

-   $$dp[i] = max(dp[i],dp[j-P[i]]+G[i])$$

这里需要注意数组索引边界,`j-P[j]>=0`不过就一般算法而言也是要注意的

```python
N=5 # 金矿容量/物品数
W=10 # 工人数/背包容量
G=[400,500,200,300,350] # 黄金含量/价值
P=[5,5,3,4,3] # 开发人数/重量

def fu(N,W,G,P):
    lis=[] # dp
    temp_lis=[] # dp temp 
    # 参考一维的,这里利用的就是滚动数组的思维
    
    # 初始化表格第一行数据
    for i in range(P[0]-1):
        lis.append(0)
        temp_lis.append(0)
    for i in range(W-P[0]+1):
        lis.append(G[0])
        temp_lis.append(0)

    for j in range(1,N):
        for i in range(W):
            if i-P[j]+1==0:
                temp_lis[i]=max(G[j],lis[i])
            if i-P[j]>=0:
                temp_lis[i]=max(lis[i],lis[i-P[j]]+G[j])
        # lis=temp_lis #不这样做为了避免对象传递的问题
        for i in range(len(lis)):
            lis[i]=temp_lis[i]
        print temp_lis
fu(N,W,G,P)
```



### 一维单点值dp

股票买入问题 #121

给定一个数组,它的第 i 个元素是一支给定股票第 i 天的价格.如果你最多只允许完成一笔交易(即买入和卖出一支股票一次),设计一个算法来计算你所能获取的最大利润.注意:你不能在买入股票前卖出股票.

```note
示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第2天(股票价格 = 1)的时候买入,在第5天(股票价格 = 6)的时候卖出,最大利润 = 6-1 = 5.注意利润不能是 7-1 = 6,因为卖出价格需要大于买入价格；同时,你不能在买入前卖出股票.
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下,没有交易完成,所以最大利润为 0.
```

如果dp[i]表示第i天的收益.但显然我们不能不买然后卖出,那我们应该从另一个角度去看待问题,即确定何时买入,显然这里利用了全局属性(统计量),如果我们想要第i天卖出入的话,什么时候其收益最大,显然是当其前i天最小值买入最好,那么我们就可以动态维护其最小值.可列出下面动态方程

-   $$dp[i]=max(dp[i-1],nums[i]-min(nums[i-1]))$$

优化后得

-   $$dp = max(dp,nums[i] - minprice)$$

写成代码为

```java
public int maxProfit(int[] prices) {
  if(prices==null||prices.length==0){
    return 0;
  }
  int n = prices.length;
  int min=Integer.MAX_VALUE;
  int dp = 0;
  for(int i=0;i<n;i++){
    min=Math.min(prices[i],min);
    dp = Math.max(dp,prices[i]-min);
  }
  return dp;
}
```

除此之外我们可以扩充其维度,即设计一个状态位j来表示买没买,

`dp[i][0]`表示未持股,第i天结束时,手头上的现金数,`dp[i][1]`表示持股第i天结束时,手头的现金数.那么策略就会如下

`dp[i][0]`

-   昨天不持股,今天什么也不做
-   昨天持股,今天卖出股票,现金数增加

`dp[i][1]`

-   昨天持股,今天什么也不做
-   昨天不持股,今天买入股票

那么当天的价格怎么样才能是最大的呢?

显然我们会发现,如果对于**今天最后要变成不持股状态**来讲,那么

-   **前一天不持股,今天啥也不做**
-   **昨天(或者更早)持股今天卖**

这两种状态能保证最后依然不持股,哪个大就选择哪个.显然这是一个让手头现金更大的选择方法

而对于**持股**来说

-   **昨天持股,今天啥也不做**
-   **昨天不持股,今天买**

维护这个状态机,我们就能得出来当天持股或者不持股的最大持有的现金数,

其状态转移方程如下,即是告诉我们当天

- $$\begin{equation} dp[i][j]=\left\{ 	\begin{aligned} 	max(dp[i - 1][0], dp[i - 1][1] + prices[i]),j=0\\  	max(dp[i - 1][1], -prices[i]), j=1 \end{aligned} \right. \end{equation}$$

优化掉i的话就是两个数组了,且我们看其,其实就是找了j=1就是全局的最小值的更新维护.

对于空间优化我们看到,如果要求最大值,其实根本不需要那么多的空间,只需要知道昨天的就行了,所以优化后其空间还能进一步减小,和0-1背包的优化一致,其只需要前面一项的信息就可以了.

-   $$\begin{equation} dp[i\  mod\ 2][j]=\left\{ 	\begin{aligned} 	max(dp[(i - 1)\ mod \ 2][0], dp[(i - 1)\ mod \ 2][1] + prices[i]),j=0\\  	max(dp[(i - 1)\ mod \ 2][1], -prices[i]), j=1 \end{aligned} \right. \end{equation}$$

这个操作称为滚动数组.



## 动态规划常见的模型

-   单点值 股票购买问题
-   线性模型 公共子序列LCS 最长递增序列LIS 以及他们加强版
-   树型模型 有待进一步接触
-   区间模型 区间dp一般根据起点终点设置二维结构 注意中间断点
-   01背包问题 金矿问题 特别需要注意遍历时候的区间



## 动态规划问题总结

关于这一系列动态规划问题

如果问题本身的值不够 需要自己去寻找或者说是建立变量二的值
最优子结构的却可以让问题的复杂度降低很多很多
但更一般的结构是去掉一个值和自身比较的情况
上述表的话 一般完整写出来对空间复杂度的提升很大
所以利用一行(这个是广义的一行)
(这个一行值得是遍历光标这行的前一行)
(同时可以利用的数据是本身这行 或者行表头 列表头a b c等)
这些数据的使用可以解决问题本身也可以大大降低空间复杂度
用好慎用
ACM

参考
递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。
每个阶段只有一个状态->递推；每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。

每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到
这个性质叫做最优子结构；
而不管之前这个状态是如何得到的
这个性质叫做无后效性。