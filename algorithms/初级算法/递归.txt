递归
尾递归:突破栈的限制
c语言可以用goto突破栈的限制

java不支持尾递归
lisp
语言没有循环语句(卧槽)

把for改成递归：

//如果无参数的话就变成死循环了
//调整参数是可以造成程序出口的
//for的实现原理值得考究
//确定参数到达一定的状态变成出口
不一定是if语句确定出口 也可以if语句确定调用范围
本质逻辑都是一样的
//
def f(){
f();
}
递归 反射？
//利用代码变换去理解调用栈递归的过程
//就是把方法换成实际等价代码，注意调用的环境！
//完全可以表达树结构的代码
//环境首先被压入栈中等到代码完全部署完毕再把所有的环境信息
//全部还原过来的时候
//
递归在进行线程的时候
把线程的代码进行了变化 指针的指向 
所以你调用的时候 实际相当于执行了那一串代码
调用栈！！！！！
这个过程与系统中断的过程非常相似 只不过再调用的时候
调用的是指针的指向 而系统中断是外部设备输入的信号


排列数算法
两个串的最大公共子序列dp
求数目比罗列更简单

浮点数 注意计算机存储方式
import java.math.BigDecimal
import java.math.mathContext

new mathContext(100) //精确到100
整数的性质
位操作
def swap(x,y):
    x=x^y
    y=y^x
    x=x^y
f(a,b)――>f(a%b,b)

求余算法
(a+b)%p=(a%p+b%p)%p
(a*b)%p=(a%p)*(b%p)%p



