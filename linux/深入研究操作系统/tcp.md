# TCP/IP 协议族

---

[toc]

[reference](http://www.52im.net/topic-tcpipvol1.html)

## 简介

tcp 在对网络方面的研究有非常举足轻重的作用,我们平时在使用 http 或者 tcp 的时候会忽略其中非常多的细节,这对于理解整个网络体系十分不友好,此处有从 web 服务器开发转移过来的知识点,具体可以参考相应的文档,此处 tcp 使用的主语言是 c++/go 来进行整个协议栈的描述.

另外一点 TCP/IP 层次及更下级的协议都是由**操作系统内核**进行实现,我们从程序层面做的只是对操作系统内核的调用而已.

![](https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70)

我们看待 TCP/IP 结构层次 和 ISO 七层模型对比,TCP 更关注其应用层面.相关重要协议也在下图中间进行标明

![](http://docs.52im.net/extend/docs/book/tcpip/vol1/1/images2/52im_1.png)

网络层有三个重要的协议

- IP 网际协议
- ICMP Internet控制报文协议
- IGMP Internet组管理协议

传输层关注两个重要协议

- TCP
- UDP

整个协议栈里面最重要的就是 TCP 协议,该协议借助 IP 协议实现,给两个 socket 之间提供了可靠的稳定性通信其主要做的工作把应用程序传下来的数据分成小隔断的数据交给ip层,**确认接受到的分组,设置发送最后确认分组的超时时间**.向应用层屏蔽这些细节,应用层只需要通过特定api接口向下层传递信息即可.TCP 可以做到拥塞控制,我们不需要考虑其网络拥塞环境.

而UDP采用不同的思路,即把可靠性保证交付由**应用层**去实现,比如差错重传等机制.



## 一个简单的 FTP 涉及到的协议

![](http://docs.52im.net/extend/docs/book/tcpip/vol1/1/images2/52im_2.png)

可以看到在TCP发送给IP的时候就已经进入了用户的内核态,所以了解此处协议即是了解内核的一个方式.应用层一般是一个用户进程,而下三层与协议栈相关的地方在内核态中.从功能职责上,链路层是为了处理通信媒介之间的处理细节,应用层是为了处理不同应用程序的通信,但网络层和运输层的区别没有那么明显.我们需要把**单个网络扩展到一组网络**,一个互连网就是一组通过相同协议族互连在一起的网络.

![第1章 概述_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/1/images2/52im_3.png)

> 应用层和运输层使用端到端（End-to-end）协议。在图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（Hop-by-hop）协议，两个端系统和每个中间系统都要使用它。

连接网络的另一个途径是使用网桥。网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网。TCP/IP 倾向于使用路由器来进行网络连接.

![第1章 概述_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/1/images2/52im_4.png)

综上我们可以稍微梳理下 FTP 整体的链路

```shell
ftp hostname
```

- 先通过 dns/hosts(小的系统使用) 获取 ip 地址
- 利用 tcp 协议进行三次握手
- 通过 ip 选路确定下一跳是本地,本地网络,还是远端网络,如果是在本地网络

## 数据链路层/网卡层

主要设备是网卡,交换机,在 linux 中有一标识叫 interface 多数命令也以 `-i` 来表示对待某些接口的命令 比如 `netstat` 或者 `tcpdump`

### 帧封装

![第2章 链路层_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/2/images2/52im_1.png)

最常使用的封装格式是RFC 894定义的格式.使用TCP必须能发送和接收采用RFC 894（以太网）封装格式的分组。

#### 尾部封装

它通过调整IP数据报中字段的次序来提高性能,把属于 TCP/IP 的首部放到了尾部,即可让数据帧的内容直接映射到一个硬件页面,节省内存到内存的复制过程.TCP数据报的长度是512字节的整数倍,正好可以用内核中的页表来处理.现基本已不做使用.

#### SLIP

Serial Line IP,串行链路的简单封装方式.其核心思路就是设计出一个结束字符.然后在接手到这个字符之后会判断接手到的信息是否有意义在决定这些信息是丢弃还是保留.

![第2章 链路层_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/2/images2/52im_2.png)

SLIP 有一个致命的缺陷

- 每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。
- 数据帧中没有类型字段,如果使用SLIP则不能用其他协议。
- 没有CRC校验

回过头来看以太网的标准帧封装考虑的更加全面,尽管如此这种简单的链路封装还是得到了大范围的使用,很多厂家都支持了这个路由协议.

#### CSLIP

压缩SLIP,串行链路性能比较低,对数据进行压缩就可以传输更多的数据.

#### ppp

点对点协议修正了SLIP中的所有缺陷.主要有一下三个部分

- 在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。
- LCP：Link Control Protocol,允许双方确认硬件,链路,配置及测试的不同.
- NCP：Network Control Protocol针对不同网络层的控制协议,允许通信双方协商网络控制协议.

ppp 相比于之前SLIP进行了一定的改进,其可以约定通信双方的是否需要压缩首部,同时数据帧带有CRC,两者都用于低速链路协议.

### 回环接口 127.0.0.1

![第2章 链路层_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/2/images2/52im_4.png)

如上图,可以看到其真实的处理是不经过数据链路层的,在网络层就把IP地址写入,像所谓的ARP/外层路由器网关等都不会经过.**所以显然的本地回环地址不会走网卡**.其会使用内核对网络层协议的实现来进行程序通信.

### MTU

Max transport unit 最大传输单元 不同的网络对应不同的传输单元.

![第1章 概述_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/2/images2/52im_5.png)

> 路径 MTU 
>
> 当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。
>
> 以太网的最小数据长度 46 Byte

```shell
netstat -a | grep tcp
netstat -i # 查看interface MTU 等信息 很好用的一个命令 可以配合 ifconfig 查看各个网络接口的信息
# 后续将会更新 netstat 关于路由表的用法
```

## 网络层和数据链路层之间

### ARP 

ARP 是 ip 层和 链路层的地址映射协议。ip 层的地址一般是 32 位,而链路层的地址是 48 位,两者需要做一层映射和转换.

ARP 是一种**网络广播**,ARP 会把数据报分发给链路上所有的 host,其语义是网络内含有 host 的主机需要应答并回传硬件地址.

![第4章 ARP:地址解析协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/4/images2/52im_2.png)

> 在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP/IP有自己的地址：32 bit的IP地址。**知道主机的IP地址并不能让内核发送一帧数据给主机**。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。
>
> 对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。

#### ARP 缓存

根据 ARP 特性,缓存优化是一个很好的点. 一般 ARP 有高速缓存,存在的表项一般是 20min,不存在的表项是 3min

```shell
❯ arp -a
? (10.128.166.12) at 9a:d0:41:28:41:21 on en0 ifscope [ethernet]
? (10.128.166.16) at ba:44:a:b1:24:9d on en0 ifscope [ethernet]
? (10.128.166.21) at c6:40:65:88:2f:cb on en0 ifscope [ethernet]
? (10.128.166.22) at 7a:81:21:ac:d9:20 on en0 ifscope [ethernet]
? (10.128.166.24) at ba:99:c0:8c:33:a1 on en0 ifscope [ethernet]
? (10.128.166.25) at 3c:6:30:47:18:bf on en0 ifscope [ethernet]
? (10.128.166.27) at da:d5:82:0:b5:e6 on en0 ifscope [ethernet]
? (10.128.166.29) at a:f7:d0:8e:1c:bc on en0 ifscope [ethernet]
? (10.128.166.32) at 12:a5:d:b9:18:57 on en0 ifscope [ethernet]
? (10.128.166.35) at d6:db:16:4e:af:67 on en0 ifscope [ethernet]
? (10.128.166.40) at 32:7:9a:57:f0:80 on en0 ifscope [ethernet]
? (10.128.166.41) at c6:59:7b:dc:3b:8 on en0 ifscope [ethernet]
? (10.128.166.42) at 96:fe:cb:8a:17:9f on en0 ifscope [ethernet]
? (10.128.166.43) at 1a:aa:7c:13:2f:73 on en0 ifscope [ethernet]
? (10.128.166.44) at 1e:1c:c6:35:cd:59 on en0 ifscope [ethernet]
? (10.128.166.52) at 7e:84:38:f:98:c1 on en0 ifscope [ethernet]
? (10.128.166.54) at 62:a:b7:21:e4:5b on en0 ifscope [ethernet]
? (10.128.166.58) at 52:11:d3:fc:f2:a on en0 ifscope [ethernet]
? (10.128.166.61) at 8e:70:f4:da:40:82 on en0 ifscope [ethernet]
? (10.128.166.254) at 9c:3a:9a:df:7e:a6 on en0 ifscope [ethernet]
? (10.128.166.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]
? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]
? (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet]
```

#### ARP代理

> 如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP).

这里其实就可以在路由器上做重定向 or 欺诈. ARP 代理的最终作用是隐藏物理网络的细节,只要路由器知道如何把相应的请求转到对应的主机上.



### RARP

大多数情况下,ARP 协议在主机的磁盘上读取ip,然后通过 arp 协议 (arp缓存) 找到对应的硬件地址.但无盘机则需要通过其他方法获取 ip 地址.

> 无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。
>
> 对应于ARP，RARP请求以广播方式传送，而RARP应答一般是单播(unicast)传送的。

RARP 的实现 和 ARP 是有区别的,

- ARP 由系统内核实现,而 RARP 则作为用户进程去实现
- ARP 服务挂掉即找不到硬件地址,而 RARP 服务通常不允许挂掉,所以会有多个节点进行冗余从而提高可用性（与之相对带来了多个ARP 应答的问题 ）





## 网络层

### IP

ip 协议有几个特点

- 不可靠: ip 协议只提供**传输**服务,当发生某个错误的时候不保证一定送达,其可靠性由上层协议保证
- 无连接: ip 数据包与 ip 数据报之间相互独立,ip 协议不维护数据包的状态信息
- ip 数据报文中虽然提供了CRC的字段,但实际上需要上层应用发现,其本身只是作为丢弃数据报的一个标识

![第3章 IP:网际协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png)

> 4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。
>
> 在c语言中,栈的生长方向是向高地址增长,我们也把这种方式叫大端 big endian 存储.
>
> 我们提到SLIP一般提供基于服务类型的排队方法，允许对交互通信数据在处理大块数据之前进行处理。由于大多数的实现都不使用TO S字段，因此这种排队机制由SLIP自己来判断和处理，驱动程序先查看协议字段（确定是否是一个TCP段），然后检查TCP信源和信宿的端口号，以判断是否是一个交互服务。一个驱动程序的注释这样认为，这种“令人厌恶的处理方法”是必需的，因为大多数实现都不允许应用程序设置TOS字段。

从上面我们其实可以知道协议的制定和路由产品的实现之间并不仅相同,协议中的某些字段可能已经丧失了相关的作用.ip 数据包的最大长度可用16位bit表示.MTU 即可达65535字节(实际上在实现的时候采用了分片的机制达不到这么大).这个分片机制主要由书剑路层在跑的协议完成。

如上面的数据结构 有个16位标识 和 8位TTL,标识写在内核,每发一份数据报,该字段自增,TTL 则是经过一个路由点则自减,到0的时候丢弃并发送 ICMP 报文告知。

#### ip 的路由选择

ip 的路由选择其实就是寻找下一跳的地址,如果目标ip不在网络中,那么ip地址将会被送往默认的路由(下一跳地址).从广义上而言,任何主机都可以被配置成路由器,由路由器来转发相应的数据报文,只不过大多数主机不这样进行配置.**IP层在内存中有个路由表**,

当收到一份数据报并进行发送的时候，路由表都会被检所一次，当ip地址为本地地址(回环)/本机在网络上的地址/广播地址等时,那么数据报会被该路由器解析处理.如果该主机被设置成路由器，那么其他地址会转发，否则会丢弃报文.

路由表中包含如下信息

> 1. 目的IP地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号（见图1-5），以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。
> 2. 下一站（或下一跳）路由器（next-hop router）的IP地址，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。
> 3. 标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口（我们将在9.2节中详细介绍这些标志）。
> 4. 为数据报的传输指定一个网络接口。
>
> ip 路由主要完成以下功能
>
> 1. 搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。
> 2. 搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论。
> 3. 搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。如果上面这些步骤都没有成功，那么该数据报就不能被传送。此时则会给应用程序返回一个网络不可达的错误.

#### 子网掩码

子网掩码的本质是前缀匹配用于判断是否为同一网络/子网,一般多用十六进制表示.



### ICMP

ICMP报文是在IP数据报内部被传输的,一般被使用作差错回传的报文.ICMP 和 IP 一样,都是使用 IP 数据报进行数据传输的,ICMP报文通常被用于**地址掩码请求和应答,时间戳请求和应答以及不可达端口**.

如下图服务类型的字段中存储了描述ICMP报文的类型,以及ICMP报文是差错报文还是查询报文,其中差错报文做了特殊的处理,不会让错误一直下去.

![第3章 IP:网际协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png)

<center>IP 数据报格式</center>

![第6章 ICMP:Internet控制报文协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/6/images2/52im_net_2.png)

<center>ICMP 数据报格式</center>

![第6章 ICMP:Internet控制报文协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/6/images2/52im_net_3.png)

一般来说一份IP报文的应答报文是ICMP,以下情况不会发送ICMP报文

> 1. ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。
> 2. 目的地址是广播地址（见图3-9）或多播地址（D类地址，见图1-5）的IP数据报。
> 3. 作为链路层广播的数据报。
> 4. 不是IP分片的第一片（将在11.5节介绍分片）。
> 5. 源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。

#### 子网掩码和时间戳

请求报文如下.

![第6章 ICMP:Internet控制报文协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/6/images2/52im_net_4.png)

![第6章 ICMP:Internet控制报文协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/6/images2/52im_net_6.png)

可以获取对应的掩码和服务器的UTC时间.关于时间戳报文,我们还可以用来计算RTT,实际上大多数主机把接受时间戳和传送时间戳设置为同样的值,但作为ICMP的接收方可能不会在意发送方的计算时间.

![第6章 ICMP:Internet控制报文协议_TCP/IP详解卷1 协议_即时通讯网(52im.net)](http://docs.52im.net/extend/docs/book/tcpip/vol1/6/images2/52im_net_8.png)









