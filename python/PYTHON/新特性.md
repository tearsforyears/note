# Python 新语法特性

---

[TOC]

## 前言

时隔3年再次进入python的世界感慨无数,此文档写于2021年8月.扩充知识体系.在对jvm内存结构中间件有了深入理解之后建立本文档,如果和其他`.txt`写成的文档发生了知识梯度请忽略此文档.感谢你我能在这条道路上一直走下去.



## async/await 语法

python 3.5 之后出现了async/await的新语法,这是python在协程上的语法糖.协程可以简单理解成异步I/O

> 当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

异步I/O基于事件驱动模型,在主线程中需要一直轮训消息的处理.

### 协程 Coroutines

协程在很早就提出来,知道最近几年才在Lua等语言中得到了广泛的使用.在线程的切换中,线程的控制模块是通过栈去实现的.内核中的PCB和TCB是其数据控制模块,协程有极高的执行效率,且因为在一个线程内进行,不会存在锁的开销.所以使用的方式最好是多进程+协程.协程由程序完全控制,Java中对其并没有实现,其中python中`yield`让线程暂停和让线程进入阻塞是有本质区别的,协程的暂停是由**程序控制**,而线程的阻塞是通过操作系统的**内核态**来进行切换.

其又被叫做**纤程(Fiber),绿色进程(Green Thread)**

![](http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg)



### yield/send语法 传值

我们说下生成器本身

```python
def foo():
    print("starting...")
    while True:
        res = yield 4
        print("res:",res)

g = foo()
print(next(g))
print("*"*20)
print(next(g))
```

如下语句,如果观察其执行结果如下

```note
starting...
4
********************
res: None
4
```

我们来分析下其执行原理,生成器到 yield 4 的时候就执行停止并且生成next返回结果了,所以在第一个next的时候并不会出现什么,因为右边的yield表达式是没有值的,所以赋值操作的时候自然是None.我们如果想要给其赋值的话,需要利用到.send()方法而不是next()

```python
def foo():
    print("starting...")
    while True:
        res = yield 4
        print("res:",res)
g = foo()
print(next(g))
print("*"*20)
print(g.send(7))
```

其结果如下

```note
starting...
4
********************
res: 7
4
```

所以我们看到其实就是代码段执行栈的一种保存.我们可以运行下列语法

```python
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
```

早期的python是用yield/send实现的,但在3.5以后就使用了async/await语法.

### async/await 语法

我们看下最基本的两种函数形式

```python
def function(): return 1
def generator(): yield 1
```

我们可以用`async`来修饰代表协程

```python
async def async_function(): return 1
async def async_generator(): yield 1
```

异步函数不会返回一个结果,而会返回一个async对象,`<coroutine object async_function at 0x102ff67d8>`

我们可以通过下列方式获取值

```python
try:
    async_function().send(None)
except StopIteration as e:
    print(e.value)
```

我们可以这么写

```python
async def async_function():
    return 1

async def await_coroutine():
    result = await async_function()
    print(result)
```

async函数有一个特点,其在函数执行的时候能够挂起,去异步执行其他函数.await是用来声明挂起后执行的程序,这个过程是不涉及CPU切换的,挂起只是行为上的,可以理解为是多异步await,**当挂起条件消失后，不管是否执行完，要马上从程序中跳出来**.在js中也有类似Callback和Promise的东西.

我们可以用下列方法执行,我们定义两个函数,为了观察其异步效果

```python
>>> async def sleep():await asyncio.sleep(1) 
  # 这里和time.sleep()不同的事asyncio是非阻塞的其会允许你完成其他的事情,即异步
  # 如果需要同步控制这件事就使用await语法,直到完成这件事才会去执行接下来的语句
>>> async def getTime():
...     print(time.time())
...     res = await sleep()
...     print(time.time())
...     print(res)
```

我们可以用asyncio库来帮我们完成这个过程,也可以使用自建函数如上`try`-`catch`形式或者使用`asyncio.run`的形式,总之await函数让我们可以等待另一个函数完成操作在继续下面的操作

```python
loop = asyncio.get_event_loop()
future = asyncio.ensure_future(getTime())
loop.run_until_complete(future)
```



